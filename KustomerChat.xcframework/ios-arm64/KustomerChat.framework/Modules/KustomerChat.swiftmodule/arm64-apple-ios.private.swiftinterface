// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name KustomerChat
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import CommonCrypto
import CoreGraphics
import CoreImage
import DeveloperToolsSupport
import Dispatch
import Foundation
@_exported import KustomerChat
import MobileCoreServices
import OSLog
import PhotosUI
import PubNub
import QuickLook
import SafariServices
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import UserNotifications
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
@_hasMissingDesignatedInitializers public class KUSUser : Swift.CustomStringConvertible {
  public var id: Swift.String?
  public var displayName: Swift.String?
  public var avatarUrl: Swift.String?
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ConnectionProvider {
  public static let shared: KustomerChat.ConnectionProvider
  public func reconnect()
  public var status: KustomerChat.KustomerConnectionStatus {
    get
  }
  public var listeners: [Swift.String : any KustomerChat.KUSConnectionListener]
  public func addListener(_ listener: any KustomerChat.KUSConnectionListener) -> Swift.String
  public func removeListener(_ uuid: Swift.String)
  public func removeAllListeners()
  @objc deinit
}
public enum KUSMessageType : Swift.Codable {
  case chatMessage
  case satisfactionResponse
  case chatSession
  case customer
  case unknown(value: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class KUSCustomer : Swift.CustomStringConvertible {
  public var id: Swift.String
  public var description: Swift.String {
    get
  }
  @objc deinit
}
public enum KustomerLanguage : Swift.String {
  case af
  case sq
  case ar
  case ar_eg
  case ar_ma
  case be
  case bs
  case bg
  case ca
  case hr
  case cs
  case da
  case nl
  case en_ca
  case en_gb
  case en_us
  case et
  case fil
  case fr
  case fr_ca
  case fr_ma
  case ka
  case de
  case el
  case he
  case hi
  case hu
  case `is`
  case id
  case it
  case ja
  case kk
  case ky
  case ko
  case lv
  case lt
  case no
  case fa
  case pl
  case br
  case pt
  case pa
  case ro
  case ru
  case sr
  case sr_me
  case zh_cn
  case sk
  case sl
  case es
  case es_ar
  case es_pa
  case es_pe
  case es_es
  case sw
  case sv
  case th
  case zh_tw
  case tr
  case tw
  case uk
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KustomerAssetLanguage : Swift.String {
  case af
  case am
  case ar
  case az
  case be
  case bg
  case bn
  case bs
  case ca
  case ceb
  case co
  case cs
  case cy
  case da
  case de
  case el
  case en
  case eo
  case es
  case et
  case eu
  case fa
  case fi
  case fr
  case fy
  case ga
  case gd
  case gl
  case gu
  case ha
  case haw
  case he
  case hi
  case hmn
  case hr
  case ht
  case hu
  case hy
  case id
  case ig
  case `is`
  case it
  case iw
  case ja
  case jw
  case ka
  case kk
  case km
  case kn
  case ko
  case ku
  case ky
  case la
  case lb
  case lo
  case lt
  case lv
  case mg
  case mi
  case mk
  case ml
  case mn
  case mr
  case ms
  case mt
  case my
  case ne
  case nl
  case no
  case ny
  case or
  case pa
  case pl
  case ps
  case pt
  case ro
  case ru
  case rw
  case sd
  case si
  case sk
  case sl
  case sm
  case sn
  case so
  case sq
  case sr
  case st
  case su
  case sv
  case sw
  case ta
  case te
  case tg
  case th
  case tk
  case tl
  case tr
  case tt
  case ug
  case uk
  case ur
  case uz
  case vi
  case xh
  case yi
  case yo
  case zh
  case zh_CN
  case zh_TW
  case zu
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class PushProvider : ObjectiveC.NSObject, UserNotifications.UNUserNotificationCenterDelegate {
  public static let shared: KustomerChat.PushProvider
  public func deregisterCurrentDeviceForPushNotifications(_ completion: @escaping ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void))
  public func didFailToRegisterForRemoteNotifications(error: any Swift.Error)
  public func didRegisterForRemoteNotifications()
  public func requestAuthorizationForPush()
  public func listLivePushChannelRegistrations(completion: ((Swift.Result<[Swift.String], KustomerChat.KError>) -> Swift.Void)? = nil)
  @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, didReceive response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)
  @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, willPresent notification: UserNotifications.UNNotification, withCompletionHandler completionHandler: @escaping (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
  @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, openSettingsFor notification: UserNotifications.UNNotification?)
  public func notificationIsFromKustomer(_ notification: UserNotifications.UNNotification) -> Swift.Bool
  public func notificationIsFromKustomer(threadIdentifier: Swift.String?) -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public struct KustomerPush : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
public struct KnowledgeBaseProvider {
  public func getRootCategory(lang: Swift.String, knowledgeBaseID: Swift.String?, completion: @escaping KustomerChat.KustomerCompletion<KustomerChat.KnowledgeBaseCategory>)
  public func getCategory(by id: Swift.String, childrenLimit: Swift.Int, lang: Swift.String, knowledgeBaseID: Swift.String?, completion: @escaping KustomerChat.KustomerCompletion<KustomerChat.KnowledgeBaseResponse>)
  public func searchArticles(term: Swift.String, page: Swift.Int, pageSize: Swift.Int, lang: Swift.String, knowledgeBaseID: Swift.String? = nil, completion: @escaping KustomerChat.KustomerCompletion<[KustomerChat.KnowledgeBaseArticle]>)
  public func getArticle(by id: Swift.String, lang: Swift.String, knowledgeBaseID: Swift.String?, completion: @escaping KustomerChat.KustomerCompletion<KustomerChat.KnowledgeBaseArticle>)
}
public protocol CoordinatorDelegate : AnyObject {
  func coordinatorWillDisappear(_ coordinator: any KustomerChat.Coordinator)
  func coordinatorWillAppear(_ coordinator: any KustomerChat.Coordinator)
  func coordinatorDidAppear(_ coordinator: any KustomerChat.Coordinator)
  func coordinatorDidDisappear(_ coordinator: any KustomerChat.Coordinator)
  func coordinatorDidHide(_ coordinator: any KustomerChat.Coordinator)
}
extension KustomerChat.CoordinatorDelegate {
  public func coordinatorWillDisappear(_ coordinator: any KustomerChat.Coordinator)
  public func coordinatorWillAppear(_ coordinator: any KustomerChat.Coordinator)
  public func coordinatorDidAppear(_ coordinator: any KustomerChat.Coordinator)
  public func coordinatorDidDisappear(_ coordinator: any KustomerChat.Coordinator)
  public func coordinatorDidHide(_ coordinator: any KustomerChat.Coordinator)
}
public struct KUSAlertSettings {
}
public typealias KUSAlertCompletionHandler = ((KustomerChat.KUSAlertResult) -> Swift.Void)
public enum KUSAlertButtonType {
  case cancel(title: Swift.String)
  case other(title: Swift.String)
  case preferred(title: Swift.String)
  case destructive(title: Swift.String)
  case textField(text: Swift.String, placeholder: Swift.String?)
}
public enum KUSAlertResult {
  case cancel
  case other(inputText: [Swift.String])
}
@_hasMissingDesignatedInitializers public class KUSAlertManager {
  @objc deinit
}
public struct KUSAlertInfo {
}
@objc @_Concurrency.MainActor(unsafe) public class KUSSWAlert : ObjectiveC.NSObject, UIKit.UIAlertViewDelegate {
  @_Concurrency.MainActor(unsafe) public static var lastTextEntered: [Swift.String?]
  @_Concurrency.MainActor(unsafe) public static func showAlert(_ title: Swift.String?, message: Swift.String?, buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil)
  @_Concurrency.MainActor(unsafe) public init(title: Swift.String?, message: Swift.String?)
  @_Concurrency.MainActor(unsafe) public func setCancelAction(_ buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func setCancelAction(_ buttonTitle: Swift.String) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func addAction(_ buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func addDestructiveAction(_ buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func addDefaultAction(_ buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func addAction(_ buttonTitle: Swift.String) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func addTextField(_ text: Swift.String, placeholder: Swift.String? = nil) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func addTextField(_ text: Swift.String) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func show()
  @_Concurrency.MainActor(unsafe) public func showActionSheet()
  @objc deinit
}
public struct KnowledgeBaseArticle : Swift.Decodable {
  public let id: Swift.String
  public let type: Swift.String
  public let attributes: KustomerChat.KnowledgeBaseArticleAttributes
  public var deflectionArticleUrl: Swift.String?
  public var deflectionArticleEmbeddedUrl: Swift.String?
  public init(from decoder: any Swift.Decoder) throws
}
public struct KnowledgeBaseArticleAttributes : Swift.Decodable {
  public var articleId: Swift.String {
    get
  }
  public let title: Swift.String
  public let htmlBody: Swift.String?
  public let lang: Swift.String
  public var published: Swift.Bool
  public let updatedAt: Foundation.Date?
  public let publishedAt: Foundation.Date?
  public let version: Swift.Int
  public let knowledgeBaseID: Swift.String?
  public let slug: Swift.String
  public let hash: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public struct BusinessHours : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum Weekday : Swift.String, Swift.Codable {
  case sunday
  case monday
  case tuesday
  case wednesday
  case thursday
  case friday
  case saturday
  case none
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct KUSKBDeflectResult : Swift.Decodable {
  public var id: Swift.String?
  public var articleId: Swift.String?
  public var type: KustomerChat.KUSKBDeflectResultType?
  public var knowledgeBaseId: Swift.String?
  public var title: Swift.String?
  public var webLink: Swift.String?
  public var articleUrl: Swift.String?
  public var articleEmbeddedUrl: Swift.String?
  public var lang: Swift.String?
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class KUSChatAttachment : Swift.CustomStringConvertible {
  final public var id: Swift.String
  final public var conversationId: Swift.String?
  final public var contentType: Swift.String?
  final public var url: Swift.String?
  final public var name: Swift.String?
  final public var chatMessageId: Swift.String?
  final public var description: Swift.String {
    get
  }
  @objc deinit
}
public struct KUSCSATForm : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct KUSCSATScale : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum KUSCSATScaleType : Swift.Codable {
  case number
  case emoji
  case thumb
  case unknown
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: KustomerChat.KUSCSATScaleType, b: KustomerChat.KUSCSATScaleType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct KUSCSATQuestion : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum KUSCSATQuestionType : Swift.String, Swift.Codable {
  case text
  case radio
  case checkbox
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class KnowledgeBaseCategoryLoader {
  @objc deinit
}
public class KUSTrackingIdentity : Swift.Decodable {
  public var id: Swift.String?
  public var customerId: Swift.String?
  public var trackingId: Swift.String?
  public var trackingToken: Swift.String?
  public var email: Swift.String?
  public var externalId: Swift.String?
  public var verified: Swift.Bool?
  public var verifiedAt: Foundation.Date?
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date?
  required public init(from decoder: any Swift.Decoder)
  @objc deinit
}
public protocol KBCategoryCollectionDataSource : AnyObject {
  var sectionTitle: Swift.String? { get }
  var rows: [KustomerChat.KnowledgeBaseDataRow] { get }
  var featuredRows: [KustomerChat.KnowledgeBaseDataRow] { get }
  var showFeaturedRows: Swift.Bool { get }
  var showFooter: Swift.Bool { get }
}
@_hasMissingDesignatedInitializers public class Settings {
  public var teamName: Swift.String {
    get
    set
  }
  public var teamIconUrl: Swift.String {
    get
    set
  }
  public var widgetType: Swift.String? {
    get
    set
  }
  public var greeting: Swift.String {
    get
    set
  }
  public var offhoursDisplay: KustomerChat.KustomerOffhoursDisplay {
    get
    set
  }
  public var offhoursMessage: Swift.String {
    get
    set
  }
  public var offhoursImageUrl: Swift.String? {
    get
    set
  }
  public var waitMessage: Swift.String? {
    get
    set
  }
  public var activeAssistant: Swift.String? {
    get
    set
  }
  public var enabled: Swift.Bool? {
    get
    set
  }
  public var didLoadSettingsFirstTime: Swift.Bool {
    get
    set
  }
  public var singleSessionChat: Swift.Bool {
    get
    set
  }
  public var closableChat: Swift.Bool {
    get
    set
  }
  public var noHistory: Swift.Bool {
    get
    set
  }
  public var showTypingIndicatorWeb: Swift.Bool {
    get
    set
  }
  public var showTypingIndicatorCustomerWeb: Swift.Bool {
    get
    set
  }
  public var autoreply: Swift.String {
    get
    set
  }
  public var embedIconUrl: Swift.String {
    get
    set
  }
  public var embedIconColor: Swift.String? {
    get
    set
  }
  public var activeForm: Swift.String? {
    get
    set
  }
  public var campaignsEnabled: Swift.Bool {
    get
    set
  }
  public var pusherAccessKey: Swift.String {
    get
    set
  }
  public var pusherCluster: Swift.String {
    get
    set
  }
  public var volumeControlTimeout: Swift.Int {
    get
    set
  }
  public var volumeControlPromptDelay: Swift.Int {
    get
    set
  }
  public var volumeControlUpfrontWaitThreshold: Swift.Int {
    get
    set
  }
  public var csatLockTime: Swift.Int? {
    get
    set
  }
  public var csatDebounceSendTime: Swift.Int {
    get
    set
  }
  public var volumeControlMode: Swift.String {
    get
    set
  }
  public var volumeControlCustomWaitMessage: Swift.String? {
    get
    set
  }
  public var volumeControlEnabled: Swift.Bool {
    get
    set
  }
  public var volumeControlMarkDoneAfterTimeout: Swift.Bool {
    get
    set
  }
  public var volumeControlUseDynamicWaitMessage: Swift.Bool {
    get
    set
  }
  public var volumeControlHideWaitOption: Swift.Bool {
    get
    set
  }
  public var showEmailInputBanner: Swift.Bool {
    get
    set
  }
  public var csatInboundMessagesOverride: Swift.Bool {
    get
    set
  }
  public var csatOutboundMessagesOverride: Swift.Bool {
    get
    set
  }
  public var volumeControlFollowUpChannels: [Swift.String] {
    get
    set
  }
  public var shouldDisableAttachments: Swift.Bool {
    get
    set
  }
  @objc deinit
}
public protocol KUSURLConvertible {
  func kus_asURL() throws -> Foundation.URL
}
extension Swift.String : KustomerChat.KUSURLConvertible {
  public func kus_asURL() throws -> Foundation.URL
}
extension Foundation.URL : KustomerChat.KUSURLConvertible {
  public func kus_asURL() throws -> Foundation.URL
}
extension Foundation.URLComponents : KustomerChat.KUSURLConvertible {
  public func kus_asURL() throws -> Foundation.URL
}
public typealias KustomerCompletion<T> = (Swift.Result<T, KustomerChat.KustomerError>) -> Swift.Void
public enum KustomerClientStatus {
  case uninitialized
  case configured
  case configurationError(error: KustomerChat.KError?)
  case starting
  case started
  case stopped
  case connected
  case disconnected
}
public protocol KUSConnectionListener {
  func onPubNubConnectionStatusChange(status: KustomerChat.KustomerConnectionStatus)
}
extension KustomerChat.KUSConnectionListener {
  public func onPubNubConnectionStatusChange(status: KustomerChat.KustomerConnectionStatus)
}
public let Kustomer: KustomerChat.KustomerClient
public typealias KUSPNTtoken = Swift.UInt64
public enum KUSKBDeflectResultType : Swift.String, Swift.Decodable {
  case article
  case category
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol CoordinatorCreator : AnyObject {
  var currentCoordinator: (any KustomerChat.Coordinator)? { get set }
  static func make() -> any KustomerChat.Coordinator
}
public struct KnowledgeBase : Swift.Decodable {
  public let id: Swift.String
  public let type: Swift.String
  public let attributes: KustomerChat.KnowledgeBaseAttributes
  public init(from decoder: any Swift.Decoder) throws
}
public struct KnowledgeBaseAttributes : Swift.Decodable {
  public let name: Swift.String
  public let subdomain: Swift.String
  public let articleSurvey: KustomerChat.KnowledgeBaseSurvey
  public let baseUrl: Swift.String?
  public init(from decoder: any Swift.Decoder) throws
}
final public class KUSKBArticle : KustomerChat.KUSKBItemBase, Swift.CustomStringConvertible {
  final public var id: Swift.String?
  final public var htmlBody: Swift.String?
  final public var title: Swift.String?
  final public var metaDescription: Swift.String?
  final public var rawJson: Swift.String?
  final public var hashIdentifier: Swift.String?
  final public var versionId: Swift.String?
  final public var slug: Swift.String?
  final public var lang: Swift.String?
  public init()
  final public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ChatProvider {
  public static let shared: KustomerChat.ChatProvider
  public var listeners: [Swift.String : any KustomerChat.KUSChatListener] {
    get
  }
  public func addChatListener(_ listener: any KustomerChat.KUSChatListener) -> Swift.String
  public func removeChatListener(_ uuid: Swift.String)
  public func removeAllChatListeners()
  public func listenForTyping(conversationId: Swift.String)
  public func stopListeningForTyping(conversationId: Swift.String)
  public func sendTypingStatus(for conversationId: Swift.String, isTyping: Swift.Bool)
  public func getConversations(completion: @escaping (Swift.Result<[KustomerChat.KUSConversation], KustomerChat.KError>) -> Swift.Void)
  public func getConversationPage(page: Swift.Int, pageSize: Swift.Int, completion: @escaping (Swift.Result<[KustomerChat.KUSConversation], KustomerChat.KError>) -> Swift.Void)
  public func getConversation(conversationId: Swift.String, completion: @escaping (Swift.Result<KustomerChat.KUSConversation, KustomerChat.KError>) -> Swift.Void)
  public func getChatMessages(conversationId: Swift.String, completion: @escaping (Swift.Result<[KustomerChat.KUSChatMessage], KustomerChat.KError>) -> Swift.Void)
  public func getChatMessagesBefore(timestamp: Foundation.Date, conversationId: Swift.String, count: Swift.Int, completion: @escaping (Swift.Result<[KustomerChat.KUSChatMessage], KustomerChat.KError>) -> Swift.Void)
  public func getHistoricChatMessages(conversationId: Swift.String, completion: @escaping (Swift.Result<[KustomerChat.KUSChatMessage], KustomerChat.KError>) -> Swift.Void)
  public func getInitialMessages(assistantId: Swift.String? = nil, startDialog: Swift.String? = nil, completion: @escaping (Swift.Result<[KustomerChat.KUSChatMessage], KustomerChat.KError>) -> Swift.Void)
  public func reloadChatSettings(_ callback: @escaping ((KustomerChat.KError?) -> Swift.Void))
  public func getUnreadCount(completion: @escaping (Swift.Result<Swift.Int, KustomerChat.KError>) -> Swift.Void)
  public func getOpenConversationCount(completion: @escaping (Swift.Result<Swift.Int, KustomerChat.KError>) -> Swift.Void)
  public func getActiveConversations(completion: @escaping (Swift.Result<[KustomerChat.KUSConversation], KustomerChat.KError>) -> Swift.Void)
  public func customerExists() -> Swift.Bool
  public func getChatSettings() -> KustomerChat.KUSChatSettings
  public func isChatAvailable() -> Swift.Bool?
  public func createConversation(firstCustomerMessage text: Swift.String? = nil, title: Swift.String? = nil, customDescribe: KustomerChat.KUSCustomDescribe? = nil, action: (any KustomerChat.KUSMessageAction)? = nil, mllNode: KustomerChat.KUSMLLNode? = nil, image: UIKit.UIImage? = nil, fileURL: Foundation.URL? = nil, overrideAssistantId: Swift.String? = nil, initialMessages: [KustomerChat.KUSInitialMessage]? = nil, completion: @escaping ((Swift.Result<(conversation: KustomerChat.KUSConversation, messages: [KustomerChat.KUSChatMessage], customer: KustomerChat.KUSCustomer?), KustomerChat.KError>) -> Swift.Void))
  public func sendChatMessage(text: Swift.String, conversationId: Swift.String, initialAgentMessages: [KustomerChat.KUSInitialMessage]? = nil, completion: @escaping ((Swift.Result<(message: KustomerChat.KUSChatMessage, conversation: KustomerChat.KUSConversation), KustomerChat.KError>) -> Swift.Void))
  public func sendChatMessage(action: any KustomerChat.KUSMessageAction, conversationId: Swift.String, additionalParams: [Swift.String : Any]? = nil, completion _outerCompletion: @escaping (Swift.Result<(message: KustomerChat.KUSChatMessage, conversation: KustomerChat.KUSConversation), KustomerChat.KError>) -> Swift.Void)
  public func sendChatMessage(text: Swift.String, assistant: KustomerChat.KUSAssistant, conversationId: Swift.String, completion _outerCompletion: @escaping (Swift.Result<(message: KustomerChat.KUSChatMessage, conversation: KustomerChat.KUSConversation), KustomerChat.KError>) -> Swift.Void)
  public func sendChatMessage(mllNode: KustomerChat.KUSMLLNode, conversationId: Swift.String, additionalParams: [Swift.String : Any]? = nil, completion _outerCompletion: @escaping (Swift.Result<(message: KustomerChat.KUSChatMessage, conversation: KustomerChat.KUSConversation), KustomerChat.KError>) -> Swift.Void)
  public func sendChatMessage(image: UIKit.UIImage, conversationId: Swift.String, completion: @escaping ((KustomerChat.KError?) -> Swift.Void))
  public func sendChatMessage(fileUrl: Foundation.URL, conversationId: Swift.String, completion: @escaping ((KustomerChat.KError?) -> Swift.Void))
  @available(*, deprecated, message: "No longer supported. Use `getInitialMessages` to fetch initial assistant messages to display, then call `createConversation` to send the first customer message.")
  public func createAssistant(id: Swift.String, startDialog: Swift.String?, after: @escaping ((KustomerChat.KUSAssistant) -> Swift.Void), error: @escaping ((KustomerChat.KError) -> Swift.Void), afterCreateConversation: ((KustomerChat.KUSConversation) -> Swift.Void)? = { _ in }) -> Swift.String
  public func endConversation(conversationId: Swift.String, completion: @escaping ((Swift.Result<KustomerChat.KUSConversation, KustomerChat.KError>) -> Swift.Void))
  public func describeConversation(conversationId: Swift.String, attributes: [Swift.String : Any], _ completion: @escaping ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void))
  public func describeCurrentCustomer(phone: Swift.String? = nil, email: Swift.String? = nil, phones: [Swift.String]? = nil, emails: [Swift.String]? = nil, facebook: Swift.String? = nil, instagram: Swift.String? = nil, twitter: Swift.String? = nil, linkedIn: Swift.String? = nil, custom: [Swift.String : Any]? = nil, _ completion: ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void)? = nil)
  public func markRead(conversationId: Swift.String)
  public func markRead(conversationId: Swift.String, messageIds: [Swift.String])
  public func sendPresenceActivity(_ presence: KustomerChat.PresenceType)
  public func submitSatisfactionForm(conversationSatisfactionId: Swift.String, response: KustomerChat.KUSCSATNetworkPostBody, conversationId: Swift.String, completion: @escaping ((Swift.Result<KustomerChat.KUSSatisfaction, KustomerChat.KError>) -> Swift.Void))
  @objc deinit
}
public enum KUSSentByType : Swift.String {
  case User
  case Customer
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class KBArticleCoordinator : KustomerChat.DataCoordinatorCreator, KustomerChat.Coordinator {
  weak final public var delegate: (any KustomerChat.CoordinatorDelegate)?
  public typealias KnowledgeBaseArticleData = (article: KustomerChat.KnowledgeBaseArticle?, id: Swift.String)
  public typealias Value = KustomerChat.KBArticleCoordinator.KnowledgeBaseArticleData
  final public var view: UIKit.UIViewController {
    get
  }
  final public var navigationController: UIKit.UINavigationController?
  final public var currentCoordinator: (any KustomerChat.Coordinator)?
  public static func make(value: KustomerChat.KBArticleCoordinator.KnowledgeBaseArticleData) -> any KustomerChat.Coordinator
  final public func show(in navigationController: UIKit.UINavigationController?)
  @objc deinit
}
public class KustomerOptions {
  public init()
  public var enableUI: Swift.Bool
  public var showInAppNotifications: Swift.Bool
  public var showAllBrandsConversationHistory: Swift.Bool
  public var language: KustomerChat.KustomerLanguage?
  @available(*, deprecated, message: "Pass a reference to the presenting view controller in the appropiate Kustomer API")
  public var hostViewController: UIKit.UIViewController?
  public var activeAssistant: KustomerChat.ActiveAssistantOptions
  public var disablePush: Swift.Bool
  public var pushBundleId: Swift.String {
    get
    set
  }
  public var pushEnvironment: KustomerChat.PushEnvironment
  public var hideNewConversationButtonInClosedChat: Swift.Bool
  public var showAnimationFor5StarCSATRatings: Swift.Bool
  public var onShow: (() -> Swift.Void)?
  public var onDismiss: (() -> Swift.Void)?
  @available(*, deprecated, message: "Use onShow instead")
  public var onViewDidAppear: ((Swift.Bool) -> Swift.Void)?
  @available(*, deprecated, message: "Use onShow instead")
  public var onViewWillAppear: ((Swift.Bool) -> Swift.Void)?
  @available(*, deprecated, message: "Use onDismiss instead")
  public var onViewWillDisappear: ((Swift.Bool) -> Swift.Void)?
  @available(*, deprecated, message: "Use onDismiss instead")
  public var onViewDidDisappear: ((Swift.Bool) -> Swift.Void)?
  public var hostDomain: Swift.String?
  public var businessScheduleId: Swift.String?
  @available(*, deprecated, message: "Use `brandId` instead whenever possible. This will override the brand id's knowledge base id.")
  public var knowledgeBaseID: Swift.String?
  public var brandId: Swift.String? {
    get
    set
  }
  public var logLevels: [KustomerChat.KustomerLogType]
  public var hideNewConversationButton: Swift.Bool
  public var hideKbArticleShare: Swift.Bool
  public var flags: Swift.String?
  @KustomerChat.KUSClamping public var messageAttachmentLocalCacheMaximumSizeInBytes: Swift.Int {
    get
    set
    _modify
  }
  public var hideHistoryNavigation: Swift.Bool
  @available(*, deprecated)
  public var orgSecret: Swift.String?
  @objc deinit
}
public enum ActiveAssistantOptions {
  case none
  case orgDefault
  case withId(Swift.String)
}
public struct PreviewDetails : Swift.Codable {
  public let lastResponder: KustomerChat.LastResponder?
  public let messageCreatedAt: Foundation.Date?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct LastResponder : Swift.Codable {
  public let type: Swift.String?
  public let displayName: Swift.String?
  public let avatarUrl: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol DataCoordinatorCreator {
  associatedtype Value
  static func make(value: Self.Value) -> any KustomerChat.Coordinator
}
public protocol KUSKBItemBase : Swift.CustomStringConvertible {
  var id: Swift.String? { get set }
  var htmlBody: Swift.String? { get set }
  var title: Swift.String? { get set }
  var metaDescription: Swift.String? { get set }
  var rawJson: Swift.String? { get set }
  var description: Swift.String { get }
}
extension KustomerChat.KUSKBItemBase {
  public func completeObject() -> [Swift.String : Any]?
}
@_hasMissingDesignatedInitializers public class KBCategoryBridge : KustomerChat.KUSKBItemBase {
  public var id: Swift.String?
  public var htmlBody: Swift.String?
  public var title: Swift.String?
  public var metaDescription: Swift.String?
  public var rawJson: Swift.String?
  public var isRoot: Swift.Bool
  public var slug: Swift.String?
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KBArticleBridge : KustomerChat.KUSKBItemBase {
  public var id: Swift.String?
  public var htmlBody: Swift.String?
  public var title: Swift.String?
  public var metaDescription: Swift.String?
  public var rawJson: Swift.String?
  public var hashIdentifier: Swift.String?
  public var slug: Swift.String?
  public var lang: Swift.String?
  public var description: Swift.String {
    get
  }
  @objc deinit
}
public struct KnowledgeBaseSurvey : Swift.Decodable {
  public let suggestedReasons: [KustomerChat.KnowledgeBaseSurveySuggestedReason]
  public let enabled: Swift.Bool
  public let suggestedReasonsEnabled: Swift.Bool
  public let writtenFeedbackEnabled: Swift.Bool
  public let ratingTitle: Swift.String
  public let ratingValues: [KustomerChat.KnowledgeBaseSurveyRatingValue]
  public let suggestedReasonsTitle: Swift.String
  public let writtenFeedbackTitle: Swift.String
  public let submitButtonText: Swift.String
  public let positiveConfirmationMessage: Swift.String
  public let negativeConfirmationMessage: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public struct KnowledgeBaseSurveySuggestedReason : Swift.Decodable {
  public let displayText: Swift.String
  public let value: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public struct KnowledgeBaseSurveyRatingValue : Swift.Decodable {
  public let value: Swift.String
  public let text: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
@propertyWrapper public struct KUSClamping<Value> : Swift.Comparable where Value : Swift.Comparable {
  public static func < (lhs: KustomerChat.KUSClamping<Value>, rhs: KustomerChat.KUSClamping<Value>) -> Swift.Bool
  public var value: Value
  public let range: Swift.ClosedRange<Value>
  public init(wrappedValue value: Value, _ range: Swift.ClosedRange<Value>)
  public var wrappedValue: Value {
    get
    set
  }
  public static func == (a: KustomerChat.KUSClamping<Value>, b: KustomerChat.KUSClamping<Value>) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class KBCategoryCoordinator : KustomerChat.DataCoordinatorCreator, KustomerChat.Coordinator {
  public typealias Value = KustomerChat.KnowledgeBaseCategoryData
  weak final public var delegate: (any KustomerChat.CoordinatorDelegate)?
  final public var view: UIKit.UIViewController {
    get
  }
  weak final public var navigationController: UIKit.UINavigationController?
  final public var currentCoordinator: (any KustomerChat.Coordinator)?
  public static func make(value: KustomerChat.KnowledgeBaseCategoryData) -> any KustomerChat.Coordinator
  public static func make() -> any KustomerChat.Coordinator
  final public func show(in navigationController: UIKit.UINavigationController?)
  @objc deinit
}
public enum KnowledgeBaseDataRow {
  case category(category: KustomerChat.KnowledgeBaseCategory, didSelect: ((_ row: KustomerChat.KnowledgeBaseCategory) -> Swift.Void)?)
  case article(article: KustomerChat.KnowledgeBaseArticle, didSelect: ((_ row: KustomerChat.KnowledgeBaseArticle) -> Swift.Void)?)
}
@objc @_Concurrency.MainActor(unsafe) final public class ConfettiView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) final public func emit(with contents: [KustomerChat.ConfettiView.Content], for duration: Foundation.TimeInterval = 3.0)
  @_Concurrency.MainActor(unsafe) @objc override final public func willMove(toSuperview newSuperview: UIKit.UIView?)
  public enum Content {
    public enum Shape {
      case circle
      case triangle
      case square
      case custom(CoreGraphics.CGPath)
    }
    case shape(KustomerChat.ConfettiView.Content.Shape, UIKit.UIColor)
    case image(UIKit.UIImage, UIKit.UIColor?)
    case text(Swift.String)
  }
  @objc deinit
}
extension KustomerChat.ConfettiView : QuartzCore.CAAnimationDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func animationDidStop(_ animation: QuartzCore.CAAnimation, finished flag: Swift.Bool)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class NextGrowingTextView : UIKit.UIScrollView {
  @_hasMissingDesignatedInitializers open class Delegates {
    open var willChangeHeight: (CoreFoundation.CGFloat) -> Swift.Void
    open var didChangeHeight: (CoreFoundation.CGFloat) -> Swift.Void
    @objc deinit
  }
  @_Concurrency.MainActor(unsafe) open var delegates: KustomerChat.NextGrowingTextView.Delegates
  @_Concurrency.MainActor(unsafe) open var textView: UIKit.UITextView {
    get
  }
  @_Concurrency.MainActor(unsafe) open var minNumberOfLines: Swift.Int {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var maxNumberOfLines: Swift.Int {
    get
    set
  }
  @available(*, deprecated, message: "Use isAutomaticScrollToBottomEnabled")
  @_Concurrency.MainActor(unsafe) open var disableAutomaticScrollToBottom: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) open var isAutomaticScrollToBottomEnabled: Swift.Bool
  @_Concurrency.MainActor(unsafe) open var placeholderAttributedText: Foundation.NSAttributedString? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var inputView: UIKit.UIView? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isFirstResponder: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func reloadInputViews()
  @objc deinit
}
public enum KustomerConnectionStatus : Swift.String {
  case connecting
  case connected
  case reconnecting
  case disconnected
  case disconnectedUnexpectedly
  public var isActive: Swift.Bool {
    get
  }
  public var isConnected: Swift.Bool {
    get
  }
  public var ableToTryReconnecting: Swift.Bool {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol KUSChatListener : AnyObject {
  func onChatMessageReceived(conversationId: Swift.String, chatMessage: KustomerChat.KUSChatMessage)
  func onConversationEnded(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  func onConversationReOpened(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  func onOpenConversationCountChange(count: Swift.Int)
  func onConversationDeleted(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  func onConversationCreated(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  func onUnreadCountChange(count: Swift.Int)
  func onUnreadCountChange(conversationId: Swift.String, count: Swift.Int)
  func onUserJoined(conversationId: Swift.String, user: KustomerChat.KUSUser)
  func onUserIsTyping(conversationId: Swift.String, user: KustomerChat.KUSUser, timetoken: KustomerChat.KUSPNTtoken?, ai: Swift.Bool)
  func onUserStopsTyping(conversationId: Swift.String, user: KustomerChat.KUSUser, timetoken: KustomerChat.KUSPNTtoken?)
  func onPreviewChanged(conversationId: Swift.String, preview: Swift.String, previewDetails: KustomerChat.PreviewDetails?)
  func onAssistantEnded(conversation: KustomerChat.KUSConversation)
  func onConversationMerged(sourceConversation: KustomerChat.KUSConversation, targetConversation: KustomerChat.KUSConversation)
  func onSatisfactionEventReceived(conversationId: Swift.String, satisfaction: KustomerChat.KUSSatisfaction)
  func onCustomerDeleted()
}
extension KustomerChat.KUSChatListener {
  public func onChatMessageReceived(conversationId: Swift.String, chatMessage: KustomerChat.KUSChatMessage)
  public func onConversationEnded(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  public func onConversationReOpened(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  public func onOpenConversationCountChange(count: Swift.Int)
  public func onConversationCreated(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  public func onUnreadCountChange(count: Swift.Int)
  public func onUnreadCountChange(conversationId: Swift.String, count: Swift.Int)
  public func onUserJoined(conversationId: Swift.String, user: KustomerChat.KUSUser)
  public func onUserIsTyping(conversationId: Swift.String, user: KustomerChat.KUSUser, timetoken: KustomerChat.KUSPNTtoken?, ai: Swift.Bool)
  public func onUserStopsTyping(conversationId: Swift.String, user: KustomerChat.KUSUser, timetoken: KustomerChat.KUSPNTtoken?)
  public func onPreviewChanged(conversationId: Swift.String, preview: Swift.String, previewDetails: KustomerChat.PreviewDetails?)
  public func onAssistantEnded(conversation: KustomerChat.KUSConversation)
  public func onConversationMerged(sourceConversation: KustomerChat.KUSConversation, targetConversation: KustomerChat.KUSConversation)
  public func onSatisfactionEventReceived(conversationId: Swift.String, satisfaction: KustomerChat.KUSSatisfaction)
  public func onConversationDeleted(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  public func onCustomerDeleted()
}
public struct KnowledgeBaseCategoryData {
}
public protocol KUSMessageAction {
  var displayText: Swift.String { get }
  var value: Swift.String { get }
}
public struct KUSButtonMessageAction : KustomerChat.KUSMessageAction, Swift.Decodable {
  public enum ValueType : Swift.String, Swift.Decodable {
    case text
    case emoji
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var displayText: Swift.String
  public var value: Swift.String
  public var valueType: KustomerChat.KUSButtonMessageAction.ValueType
  public init(from decoder: any Swift.Decoder) throws
}
public struct KUSObjectMessageAction : KustomerChat.KUSMessageAction, Swift.Decodable {
  public var displayText: Swift.String {
    get
  }
  public var value: Swift.String
  public var titleText: Swift.String?
  public var detailsText: Swift.String?
  public var imageUrl: Swift.String?
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class KUSMLLNode : Swift.Decodable {
  public var displayText: Swift.String?
  public var value: Swift.String?
  @objc deinit
  required public init(from decoder: any Swift.Decoder) throws
}
public struct KUSCSATResponse : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum KUSCSATStatus : Swift.String, Swift.Codable {
  case offered
  case rated
  case commented
  case scheduled
  case unresponded
  case canceled
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct KUSCSATAnswer : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct KUSCSATNetworkPostBody : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct AILabelConstants {
}
@available(*, unavailable, renamed: "Notification.Name.KUS_reachabilityChanged")
public let KUSReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let KUSReachabilityChanged: Foundation.Notification.Name
}
public struct KUSConversation : Swift.CustomStringConvertible, Swift.Codable {
  public var id: Swift.String?
  public var createdAt: Foundation.Date?
  public var lastMessageAt: Foundation.Date?
  @available(*, deprecated, message: "`status` field no longer supported - use `lockedAt` or `lockReason` to determine the status of a KUSConversation")
  public var status: KustomerChat.KUSConversationStatus? {
    get
  }
  public var brandId: Swift.String?
  public var lockedAt: Foundation.Date?
  public var lockedByCustomer: Swift.Bool?
  public var lockReason: KustomerChat.KUSConversationLockReason?
  public var preview: Swift.String?
  public var previewDetails: KustomerChat.PreviewDetails?
  public var respondingUserIds: [Swift.String?]?
  public var unreadMessageCount: Swift.Int?
  public var lastReadMessageId: Swift.String?
  public var isDeleted: Swift.Bool
  public var users: [KustomerChat.KUSUser] {
    mutating get
    set
  }
  public var localUuid: Swift.String?
  public var description: Swift.String {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct KUSChatMessageTemplateMeta : Swift.CustomStringConvertible, Swift.Decodable {
  public var isAiResponse: Swift.Bool?
  public var lockInput: Swift.Bool?
  public var description: Swift.String {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public enum KUSChatMessageDirection : Swift.String, Swift.Decodable {
  case inbound
  case outbound
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KUSChatMessageDirectionType : Swift.String, Swift.Decodable {
  case initialIn
  case initialOut
  case followupOut
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class EventBroadcaster {
  @objc deinit
}
extension KustomerChat.KustomerUI.Color {
  public static var activeLinkColor: UIKit.UIColor
  public static var chatAvatarBackground: UIKit.UIColor
  public static var chatAvatarInitials: UIKit.UIColor
  public static var chatHeaderBackground: UIKit.UIColor
  public static var chatHeaderBackgroundWhenInAssistant: UIKit.UIColor
  public static var chatInputBarBackground: UIKit.UIColor
  public static var chatSearchBarBackground: UIKit.UIColor
  public static var chatTableBackground: UIKit.UIColor
  public static var chatTextInputBackground: UIKit.UIColor
  public static var chatNewConversationButton: UIKit.UIColor
  public static var chatNewConversationButtonText: UIKit.UIColor
  public static var chatEndedRowText: UIKit.UIColor
  public static var chatEndedRowLine: UIKit.UIColor
  public static var csatText: UIKit.UIColor
  public static var csatCommentBoxBackground: UIKit.UIColor
  public static var csatCommentBoxOutline: UIKit.UIColor
  public static var historyBackground: UIKit.UIColor
  public static var historyBadgeBackground: UIKit.UIColor
  public static var historyBadgeText: UIKit.UIColor
  public static var historyEmptyStateBackground: UIKit.UIColor
  public static var historyHeaderBackground: UIKit.UIColor
  public static var historyNewChatButton: UIKit.UIColor
  public static var historyNewChatButtonText: UIKit.UIColor
  public static var historyRowBackground: UIKit.UIColor
  public static var historyTitleColor: UIKit.UIColor
  public static var incomingMessageBubble: UIKit.UIColor
  public static var incomingMessageText: UIKit.UIColor
  public static var loadingNavigationHeaderSeparator: UIKit.UIColor
  public static var loadingViewBackground: UIKit.UIColor
  public static var messageUrlLinkOnAgentBubble: UIKit.UIColor
  public static var messageUrlLinkOnCustomerBubble: UIKit.UIColor
  public static var messageLinkInHistoryList: UIKit.UIColor
  public static var messagesBackground: UIKit.UIColor
  public static var navigationBarButton: UIKit.UIColor
  public static var outgoingMessageBubble: UIKit.UIColor
  public static var outgoingMessageText: UIKit.UIColor
  public static var tabBarBackground: UIKit.UIColor
  public static var tabBarItemColor: UIKit.UIColor
  public static var tabBarUnselectedItemColor: UIKit.UIColor
  public static var kbBrowseBackground: UIKit.UIColor
  public static var kbBrowseSeparator: UIKit.UIColor
  public static var kbLoadingProgressTintColor: UIKit.UIColor
  public static var kbLoadingTintColor: UIKit.UIColor
  public static var kobjectButton: UIKit.UIColor
  public static var kobjectButtonText: UIKit.UIColor
  public static var kbBrowseRowTitle: UIKit.UIColor
  public static var kbBrowseRowSubtitle: UIKit.UIColor
  public static var kbBrowseCategoryDescriptionText: UIKit.UIColor
  public static var kbBrowseIconTint: UIKit.UIColor
  public static var kbHeader: UIKit.UIColor
  public static var kbHeaderText: UIKit.UIColor
  public static var kbHeaderTint: UIKit.UIColor
  public static var chatMllMenuOpenBackdrop: UIKit.UIColor
  public static var mllOptionText: UIKit.UIColor
  public static var mllMenuTitleText: UIKit.UIColor
  public static var mllMenuBackTint: UIKit.UIColor
  public static var quickActionButton: UIKit.UIColor
  public static var quickActionButtonText: UIKit.UIColor
  public static var sendChatMessageButton: UIKit.UIColor
  public static var noInternetBannerBackground: UIKit.UIColor
  public static var noInternetBannerText: UIKit.UIColor
}
public protocol Coordinator : AnyObject {
  var delegate: (any KustomerChat.CoordinatorDelegate)? { get set }
  var view: UIKit.UIViewController { get }
  var navigationController: UIKit.UINavigationController? { get set }
  func show(in navigationController: UIKit.UINavigationController?)
  func present(in controller: UIKit.UIViewController)
}
extension KustomerChat.Coordinator {
  public func show(in navigationController: UIKit.UINavigationController?)
  public func present(in controller: UIKit.UIViewController)
}
public enum KustomerConfigurationError : Swift.Error {
  case notEnoughDiskSpace
  public static func == (a: KustomerChat.KustomerConfigurationError, b: KustomerChat.KustomerConfigurationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension KustomerChat.KustomerConfigurationError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum KUSConversationLockReason : Swift.String {
  case customer_ended
  case user_ended
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KnowledgeBaseDocumentType : Swift.String, Swift.Decodable {
  case article, category
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KBDocument : Swift.Decodable {
  case article(KustomerChat.KnowledgeBaseArticle)
  case category(KustomerChat.KnowledgeBaseCategory)
  public init(from decoder: any Swift.Decoder) throws
}
public struct KnowledgeBaseResponse : Swift.Decodable {
  public let data: KustomerChat.KnowledgeBaseCategory
  public var subCategories: [KustomerChat.KnowledgeBaseCategory]? {
    get
  }
  public var articles: [KustomerChat.KnowledgeBaseArticle]? {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct KnowledgeBaseCategory : Swift.Decodable {
  public let id: Swift.String
  public let type: KustomerChat.KnowledgeBaseDocumentType
  public let attributes: KustomerChat.KnowledgeBaseCategoryAttributes
  public init(from decoder: any Swift.Decoder) throws
}
public struct KnowledgeBaseCategoryAttributes : Swift.Decodable {
  public let title: Swift.String?
  public let description: Swift.String?
  public var disabled: Swift.Bool?
  public let positions: [Swift.String]
  public let categoryPositions: [Swift.String]
  public let parent: Swift.String?
  public let createdAt: Foundation.Date
  public let updatedAt: Foundation.Date
  public var published: Swift.Bool?
  public var deleted: Swift.Bool?
  public let slug: Swift.String?
  public let hash: Swift.String?
  public var root: Swift.Bool?
  public init(from decoder: any Swift.Decoder) throws
}
public class KUSChatSettings {
  public init(userDefaults: Foundation.UserDefaults)
  public var dictionaryRepresentation: [Swift.String : Any] {
    get
  }
  @objc deinit
}
public enum KustomerOffhoursDisplay : Swift.String {
  case none
  case offline
  case online
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KnowledgeBaseCategoryViewMode : Swift.CaseIterable {
  case rootCategory
  case subCategory
  public static func == (a: KustomerChat.KnowledgeBaseCategoryViewMode, b: KustomerChat.KnowledgeBaseCategoryViewMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [KustomerChat.KnowledgeBaseCategoryViewMode]
  public static var allCases: [KustomerChat.KnowledgeBaseCategoryViewMode] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public enum KUSChatMessageStatus {
  case success
  case error
  case sending
  case cancelled
  public static func fromString(_ s: Swift.String?) -> KustomerChat.KUSChatMessageStatus
  public static func == (a: KustomerChat.KUSChatMessageStatus, b: KustomerChat.KUSChatMessageStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum KUSMessageTemplateType : Swift.String, Swift.Decodable {
  case quickReplies
  case mll
  case deflection
  case text
  case list
  case feedback
  case none
  public static func fromString(_ s: Swift.String?) -> KustomerChat.KUSMessageTemplateType
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum PresenceType {
  case online
  case offline
  public static func == (a: KustomerChat.PresenceType, b: KustomerChat.PresenceType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum KError : Swift.Error {
  case named(Swift.String)
  case generic(any Swift.Error)
  case alamofire(KustomerChat.KUSAFError)
  case api(details: [Any]?)
  case notEnoughDiskSpace
  case noAPSEnvironmentEntitlement
  case invalidDeviceToken
  case pushRegistrationNotNeededNoCustomerIPC
  case noDeviceToken
  case identificationFailed(Swift.String)
  case loginValidationError(error: Swift.String)
  case channelGroupNameNotFound
  case invalidJwt
  case alreadyIdentifiedWithExternalId(externalId: Swift.String)
  case alreadyIdentifiedWithEmail(email: Swift.String)
  case networkErrorLoadingSettings(KustomerChat.KustomerError)
  case noPubNubClient
  case couldNotDeregisterPush
  case couldNotDeregisterPushBecause(any Swift.Error)
  case couldNotDeregisterPushBecauseOf(Swift.String)
  case attachmentTooLarge
  case attachmentTypeNotSupported
  case localFileURLExpired
  case localFileURLHasNoData
  case unknownLanguageCode(Swift.String)
  case describe(details: [Any]?)
  case describeUnknownParameter(parameter: Swift.String, details: [Any]?)
  case describeParameterWrongType(parameter: Swift.String, details: [Any]?)
  case describeNoParamtersSpecified
  case describeCustomerDateParametersNotSupported
  case describeNotAvailableForLocalCustomer
  case describeNotSignedInAsThatCustomerId
  case describeCurrentCustomerIsAnonymous
  case kbNetworkError
  case kbArticleIdNotFound
  case kbCategoryIdNotFound
  case localDataStoreError
  case kbNoParentCategoryIdSpecified
  case invalidConversationId
  case malformedConversationId
  case unauthorizedConversationId
  case genericOpenConversationError(details: Swift.String)
  case couldNotCreateSession
  case cancelledMessageCreateDataRequest
  case chatEnded
  case internetOffline
  case invalidAssistantId
  case noInternetAvailableAndNoCachedChatAssistantFound
  case couldNotReadLocalFile
  case httpAttachmentUploadWasCancelled
  case invalidBusinessScheduleId
  case invalidBrandId
  case chatAvailError(reason: Swift.String)
  case noCustomerMetaChannelName
  case pubsubHistoryLoadError(failed: [Swift.String : KustomerChat.KError])
  case tooManyChannelKeysInHistoricalCustomerEvents
  case couldNotLoadMessageHistory(error: any Swift.Error)
}
extension KustomerChat.KError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class KUSSatisfaction : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public enum KustomerDisplayMode {
  case `default`
  case chatHistory
  case newChat
  case activeChat
  case knowledgeBase
  case knowledgeBaseHome
  case onlyChat
  case onlyKnowledgeBase
  public static func == (a: KustomerChat.KustomerDisplayMode, b: KustomerChat.KustomerDisplayMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum KUSConversationStatus {
  case open
  case ended
  case new
  public static func == (a: KustomerChat.KUSConversationStatus, b: KustomerChat.KUSConversationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NetworkError : Swift.Error, Foundation.LocalizedError {
  case failed((any Swift.Error)?)
  case outdated
  case badRequest(Swift.Int, [Swift.String : Swift.AnyObject]?)
  case serverError(Swift.Int, [Swift.String : Swift.AnyObject]?)
  case authenticationError
  case requestError(KustomerChat.RequestError)
  case responseError(KustomerChat.ResponseError)
  public var errorDescription: Swift.String? {
    get
  }
}
public enum RequestError : Swift.Error, Foundation.LocalizedError {
  case invalidRequest(Swift.String)
  case parametersNil
  case parameterEncodingFailed(KustomerChat.ParameterEncodingFailureReason)
  public var errorDescription: Swift.String? {
    get
  }
}
public enum ParameterEncodingFailureReason {
  case missingUrl
  case jsonEncoding(any Swift.Error)
  public var description: Swift.String? {
    get
  }
}
public enum ResponseError : Swift.Error, Foundation.LocalizedError {
  case unableToDecode(Swift.DecodingError)
  case noData(Swift.String)
  case noContent
  public var errorDescription: Swift.String? {
    get
  }
}
public enum KUSAFError : Swift.Error {
  public enum KUSMultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: any Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: any Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: any Swift.Error)
    case inputStreamReadFailed(error: any Swift.Error)
  }
  public enum KUSParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: any Swift.Error)
    case customEncodingFailed(error: any Swift.Error)
  }
  public enum KUSParameterEncoderFailureReason {
    public enum KUSRequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(KustomerChat.KUSAFError.KUSParameterEncoderFailureReason.KUSRequiredComponent)
    case encoderFailed(error: any Swift.Error)
  }
  public enum KUSResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: any Swift.Error)
  }
  public enum KUSResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: any Swift.Error)
    case decodingFailed(error: any Swift.Error)
    case customSerializationFailed(error: any Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum KUSServerTrustFailureReason {
    public struct KUSOutput {
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: (any Swift.Error)?)
    case defaultEvaluationFailed(output: KustomerChat.KUSAFError.KUSServerTrustFailureReason.KUSOutput)
    case hostValidationFailed(output: KustomerChat.KUSAFError.KUSServerTrustFailureReason.KUSOutput)
    case revocationCheckFailed
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: any Swift.Error)
  }
  public enum KUSURLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: any Swift.Error)
  case createURLRequestFailed(error: any Swift.Error)
  case downloadedFileMoveFailed(error: any Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: any KustomerChat.KUSURLConvertible)
  case multipartEncodingFailed(reason: KustomerChat.KUSAFError.KUSMultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: KustomerChat.KUSAFError.KUSParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: KustomerChat.KUSAFError.KUSParameterEncoderFailureReason)
  case requestAdaptationFailed(error: any Swift.Error)
  case requestRetryFailed(retryError: any Swift.Error, originalError: any Swift.Error)
  case responseValidationFailed(reason: KustomerChat.KUSAFError.KUSResponseValidationFailureReason)
  case responseSerializationFailed(reason: KustomerChat.KUSAFError.KUSResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: KustomerChat.KUSAFError.KUSServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: (any Swift.Error)?)
  case sessionTaskFailed(error: any Swift.Error)
  case urlRequestValidationFailed(reason: KustomerChat.KUSAFError.KUSURLRequestValidationFailureReason)
  case kustomerAddOnError(error: Foundation.NSError)
}
extension KustomerChat.KUSAFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum KustomerLogType : Swift.String {
  case debug
  case warning
  case error
  case info
  case fatal
  @available(*, deprecated)
  case multithreadingWarning
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public let KustomerLogTypeAll: [KustomerChat.KustomerLogType]
public typealias KUSCustomDescribe = [Swift.String : Any]
@objc @_hasMissingDesignatedInitializers final public class KustomerClient : ObjectiveC.NSObject {
  final public var chatProvider: KustomerChat.ChatProvider {
    get
    set
  }
  final public var kbProvider: KustomerChat.KnowledgeBaseProvider {
    get
    set
  }
  final public var pushProvider: KustomerChat.PushProvider
  public static let shared: KustomerChat.KustomerClient
  final public var status: KustomerChat.KustomerClientStatus
  final public var bundle: Foundation.Bundle
  final public var sdkVersion: Swift.String {
    get
  }
  final public var sdkVersionBuild: Swift.String {
    get
  }
  final public var sdkVersionSemver: Swift.String {
    get
  }
  final public var rootViewController: KustomerChat.SupportTabViewController? {
    get
  }
  final public class var isRunningOnSimulator: Swift.Bool {
    get
  }
  final public func changeActiveAssistant(_ na: KustomerChat.ActiveAssistantOptions)
  final public func changeBusinessSchedule(scheduleId: Swift.String?, completion: ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void)? = nil)
  final public func getActiveAssistantID() -> Swift.String?
  final public func getActiveAssistantStartDialog() -> Swift.String?
  final public var options: KustomerChat.KustomerOptions {
    get
  }
  final public var orgId: Swift.String
  final public var orgName: Swift.String {
    get
    set
  }
  @available(*, deprecated)
  final public var apiKeyRaw: Swift.String? {
    get
  }
  final public func configure(apiKey: Swift.String, options: KustomerChat.KustomerOptions?, launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]?, completion: ((KustomerChat.KustomerConfigurationError) -> ())? = { _ in }, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line) -> KustomerChat.KustomerClient
  final public func configureUnsafe(apiKey: Swift.String, options: KustomerChat.KustomerOptions?, launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]?, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line) -> KustomerChat.KustomerClient
  final public func isChatAvailable() -> Swift.Bool?
  final public func show(presentingVC: UIKit.UIViewController? = nil)
  final public func show(preferredView: KustomerChat.KustomerDisplayMode, presentingVC: UIKit.UIViewController? = nil)
  final public func openConversation(id: Swift.String, animated: Swift.Bool = true, presentingVC: UIKit.UIViewController? = nil, completion: ((Swift.Result<KustomerChat.KUSConversation, KustomerChat.KError>) -> Swift.Void)? = nil)
  final public func showKbArticle(id: Swift.String, presentingVC: UIKit.UIViewController? = nil)
  final public func showKbCategory(id: Swift.String, presentingVC: UIKit.UIViewController? = nil)
  final public func close(animated: Swift.Bool = true, completion passedCompletion: (() -> Swift.Void)?)
  final public var isVisible: Swift.Bool {
    get
  }
  final public func isLoggedIn(userEmail: Swift.String?, userId: Swift.String?) -> Swift.Bool
  @available(*, deprecated, message: "Use isLoggedIn(userEmail: String?, userId: String?) -> Bool")
  final public func isLoggedIn(userEmail: Swift.String?, userId: Swift.String?, completion: @escaping ((Swift.Result<Swift.Bool, KustomerChat.KError>) -> Swift.Void))
  final public func logOut(_ completion: @escaping ((KustomerChat.KError?) -> Swift.Void))
  final public func logIn(jwt: Swift.String, _ completion: @escaping ((Swift.Result<KustomerChat.KUSTrackingIdentity, KustomerChat.KError>) -> Swift.Void))
  final public func logOutThenLogIn(jwt: Swift.String, _ completion: @escaping ((Swift.Result<KustomerChat.KUSTrackingIdentity, KustomerChat.KError>) -> Swift.Void))
  @available(*, deprecated, message: "Use startNewConversation() instead")
  final public func openNewConversation(initialMessages: [Swift.String]? = nil, presentingVC: UIKit.UIViewController? = nil, afterCreateConversation: ((KustomerChat.KUSConversation) -> Swift.Void)? = nil, animated: Swift.Bool = true)
  final public func startNewConversation(initialMessage: KustomerChat.KUSInitialMessage? = nil, customDescribe: KustomerChat.KUSCustomDescribe? = nil, presentingVC: UIKit.UIViewController? = nil, afterCreateConversation: ((KustomerChat.KUSConversation) -> Swift.Void)? = nil, animated: Swift.Bool = true)
  final public func didFailToRegisterForRemoteNotifications(error: any Swift.Error)
  final public func didRegisterForRemoteNotifications(deviceToken: Foundation.Data)
  final public func deregisterCurrentDeviceForPushNotifications(_ completion: @escaping ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void))
  final public func requestAuthorizationForPush()
  final public func stop()
  final public func start(completion: @escaping (() -> Swift.Void), failure: @escaping ((any Swift.Error) -> Swift.Void))
  final public func start()
  final public func start(completion: @escaping (() -> Swift.Void))
  final public func start(failure: @escaping ((any Swift.Error) -> Swift.Void))
  @available(*, deprecated, message: "It is now reccomended to have your application receive push notifications and pass them to the Kustomer SDK as needed. See https://developer.kustomer.com/chat-sdk/v2-iOS/docs/push-notifications#implement-kustomer-sdk-as-secondary-handler for more information")
  final public var unUserNotificationCenterDelegate: (any UserNotifications.UNUserNotificationCenterDelegate)? {
    get
    set
  }
  final public func printLocalizationKeys()
  @available(*, deprecated, message: "This functionality is deprecated and will be removed in a future version. Please user KustomerOptions.language to set a language")
  final public func overrideAssetLanguage(languageCode: KustomerChat.KustomerAssetLanguage)
  final public func openChatAssistant(id: Swift.String, startDialog: Swift.String?, presentingVC: UIKit.UIViewController? = nil, completion: @escaping ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void), afterFirstMessage: @escaping ((KustomerChat.KUSConversation) -> Swift.Void) = { c in }, initialMessages: [Swift.String]? = nil, customDescribe: KustomerChat.KUSCustomDescribe? = nil, animated: Swift.Bool = true)
  final public func getUnreadCount(completion: @escaping (Swift.Result<Swift.Int, KustomerChat.KError>) -> Swift.Void)
  final public func getOpenConversationCount(completion: @escaping (Swift.Result<Swift.Int, KustomerChat.KError>) -> Swift.Void)
  @objc deinit
}
extension KustomerChat.KustomerClient : UIKit.UIAdaptivePresentationControllerDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func presentationControllerDidDismiss(_ presentationController: UIKit.UIPresentationController)
}
extension Foundation.Bundle {
  public static func getBundle(bundleName: Swift.String) -> Foundation.Bundle?
  public static let kustomerAssets: Foundation.Bundle?
}
public enum PushEnvironment : Swift.String {
  case development
  case production
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class Schedules {
  public var timeZone: Swift.String {
    get
    set
  }
  public var hours: [KustomerChat.BusinessHours] {
    get
    set
  }
  public var holidays: [KustomerChat.BusinessHoliday] {
    get
    set
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KUSAssistant : Swift.CustomStringConvertible, Swift.Decodable {
  public var dialog: Swift.String
  public var id: Swift.String
  public var node: Swift.String
  public var initialMessagesRawJson: [Any]
  public var publicName: Swift.String?
  public var avatarUrl: Swift.String?
  public var messages: [KustomerChat.KUSChatMessage] {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class SupportTabViewController : UIKit.UITabBarController {
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidLayoutSubviews()
  @_Concurrency.MainActor(unsafe) final public var isCurrentlyVisible: Swift.Bool {
    get
  }
}
extension KustomerChat.SupportTabViewController : KustomerChat.KUSChatListener {
  @_Concurrency.MainActor(unsafe) final public func onUnreadCountChange(count: Swift.Int)
}
extension KustomerChat.SupportTabViewController : KustomerChat.CoordinatorDelegate {
  @_Concurrency.MainActor(unsafe) final public func coordinatorDidHide(_ coordinator: any KustomerChat.Coordinator)
}
public struct BusinessHoliday : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum KustomerError : Swift.Error {
  case networkError(KustomerChat.NetworkError)
  case someError(Swift.String)
}
extension KustomerChat.KustomerError : Foundation.LocalizedError {
  public var failureReason: Swift.String? {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
}
public struct KSet : Swift.Decodable {
  public var publishKey: Swift.String?
  public var subscribeKey: Swift.String?
  public var brand: Swift.String?
  public init(from decoder: any Swift.Decoder) throws
}
public struct KnowledgeBaseSurveyResponse : Swift.Decodable {
  public let id: Swift.String
  public let attributes: KustomerChat.KnowledgeBaseSurveyResponseAttributes
  public init(from decoder: any Swift.Decoder) throws
}
public struct KnowledgeBaseSurveyResponseAttributes : Swift.Codable {
  public let rating: KustomerChat.KBSurveyRating?
  public let writtenFeedback: Swift.String?
  public let suggestedReasons: [Swift.String]?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum KBSurveyRating : Swift.String, Swift.Codable {
  case positive
  case negative
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol KBCategoryCollectionManager : AnyObject {
  var dataSource: (any KustomerChat.KBCategoryCollectionDataSource)? { get set }
  func reload()
}
public class KUSKBCategory : KustomerChat.KUSKBItemBase, Swift.CustomStringConvertible {
  public var id: Swift.String?
  public var htmlBody: Swift.String?
  public var title: Swift.String?
  public var metaDescription: Swift.String?
  public var rawJson: Swift.String?
  public var isRoot: Swift.Bool
  public var categoryDescription: Swift.String?
  public var lang: Swift.String?
  public var slug: Swift.String?
  public init()
  public var description: Swift.String {
    get
  }
  @objc deinit
}
public struct KUSChatMessage : Swift.CustomStringConvertible, Swift.Decodable {
  public var id: Swift.String
  public var conversationId: Swift.String?
  public var brandId: Swift.String?
  public var createdAt: Foundation.Date?
  public var status: KustomerChat.KUSChatMessageStatus?
  public var messageType: KustomerChat.KUSMessageType?
  public var direction: KustomerChat.KUSChatMessageDirection?
  public var directionType: KustomerChat.KUSChatMessageDirectionType?
  public var body: Swift.String?
  public var attachments: [KustomerChat.KUSChatAttachment]
  public var templateType: KustomerChat.KUSMessageTemplateType?
  public var sentByUser: KustomerChat.KUSUser?
  public var sentById: Swift.String?
  public var sentByType: KustomerChat.KUSSentByType?
  public var actions: [any KustomerChat.KUSMessageAction]?
  public var mllNode: KustomerChat.KUSMLLNode? {
    get
    set
  }
  public var deflectResults: [KustomerChat.KUSKBDeflectResult]?
  public var followupText: Swift.String?
  public var satisfaction: KustomerChat.KUSSatisfaction?
  public var pubNubTimetoken: Swift.UInt64?
  public var templateRawJson: Swift.String?
  public var previewSummary: Swift.String {
    get
  }
  public var isAiResponse: Swift.Bool?
  public var lockInput: Swift.Bool?
  public init(from decoder: any Swift.Decoder) throws
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ChatHistoryCoordinator : KustomerChat.CoordinatorCreator, KustomerChat.Coordinator {
  weak final public var delegate: (any KustomerChat.CoordinatorDelegate)?
  final public var view: UIKit.UIViewController
  weak final public var navigationController: UIKit.UINavigationController?
  final public var currentCoordinator: (any KustomerChat.Coordinator)?
  public static func make() -> any KustomerChat.Coordinator
  final public func show(in navigationController: UIKit.UINavigationController?)
  @objc deinit
}
public enum KustomerUI {
}
extension KustomerChat.KustomerUI {
  @_hasMissingDesignatedInitializers public class Color {
    @objc deinit
  }
}
extension KustomerChat.KustomerUI.Color {
  public static var systemBackground: UIKit.UIColor {
    get
  }
  public static var secondarySystemGroupedBackground: UIKit.UIColor {
    get
  }
  public static var systemGray5: UIKit.UIColor {
    get
  }
  public static var tertiarySystemGroupedBackground: UIKit.UIColor {
    get
  }
  public static var label: UIKit.UIColor {
    get
  }
  public static var secondaryLabel: UIKit.UIColor {
    get
  }
  public static var tertiaryLabel: UIKit.UIColor {
    get
  }
  public static var systemGray3: UIKit.UIColor {
    get
  }
  public static var systemFill: UIKit.UIColor {
    get
  }
  public static func color(_ named: Swift.String) -> UIKit.UIColor
}
public struct KnowledgeBaseDomain : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension KustomerChat.KnowledgeBaseDomain {
  public struct Attributes : Swift.Decodable {
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension KustomerChat.KnowledgeBaseDomain {
  public enum Status : Swift.Codable, Swift.RawRepresentable {
    public typealias RawValue = Swift.String
    case ready
    case some(value: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public init(rawValue: Swift.String)
  }
}
public struct KUSInitialMessage : Swift.Encodable {
  public init(body: Swift.String, direction: KustomerChat.KUSInitialMessageDirection)
  public func encode(to encoder: any Swift.Encoder) throws
}
public enum KUSInitialMessageDirection : Swift.String, Swift.Encodable {
  case agent
  case user
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension KustomerChat.KustomerLanguage : Swift.Equatable {}
extension KustomerChat.KustomerLanguage : Swift.Hashable {}
extension KustomerChat.KustomerLanguage : Swift.RawRepresentable {}
extension KustomerChat.KustomerAssetLanguage : Swift.Equatable {}
extension KustomerChat.KustomerAssetLanguage : Swift.Hashable {}
extension KustomerChat.KustomerAssetLanguage : Swift.RawRepresentable {}
extension KustomerChat.Weekday : Swift.Equatable {}
extension KustomerChat.Weekday : Swift.Hashable {}
extension KustomerChat.Weekday : Swift.RawRepresentable {}
extension KustomerChat.KUSCSATScaleType : Swift.Equatable {}
extension KustomerChat.KUSCSATScaleType : Swift.Hashable {}
extension KustomerChat.KUSCSATQuestionType : Swift.Equatable {}
extension KustomerChat.KUSCSATQuestionType : Swift.Hashable {}
extension KustomerChat.KUSCSATQuestionType : Swift.RawRepresentable {}
extension KustomerChat.KUSKBDeflectResultType : Swift.Equatable {}
extension KustomerChat.KUSKBDeflectResultType : Swift.Hashable {}
extension KustomerChat.KUSKBDeflectResultType : Swift.RawRepresentable {}
extension KustomerChat.KUSSentByType : Swift.Equatable {}
extension KustomerChat.KUSSentByType : Swift.Hashable {}
extension KustomerChat.KUSSentByType : Swift.RawRepresentable {}
extension KustomerChat.KustomerConnectionStatus : Swift.Equatable {}
extension KustomerChat.KustomerConnectionStatus : Swift.Hashable {}
extension KustomerChat.KustomerConnectionStatus : Swift.RawRepresentable {}
extension KustomerChat.KUSButtonMessageAction.ValueType : Swift.Equatable {}
extension KustomerChat.KUSButtonMessageAction.ValueType : Swift.Hashable {}
extension KustomerChat.KUSButtonMessageAction.ValueType : Swift.RawRepresentable {}
extension KustomerChat.KUSCSATStatus : Swift.Equatable {}
extension KustomerChat.KUSCSATStatus : Swift.Hashable {}
extension KustomerChat.KUSCSATStatus : Swift.RawRepresentable {}
extension KustomerChat.KUSChatMessageDirection : Swift.Equatable {}
extension KustomerChat.KUSChatMessageDirection : Swift.Hashable {}
extension KustomerChat.KUSChatMessageDirection : Swift.RawRepresentable {}
extension KustomerChat.KUSChatMessageDirectionType : Swift.Equatable {}
extension KustomerChat.KUSChatMessageDirectionType : Swift.Hashable {}
extension KustomerChat.KUSChatMessageDirectionType : Swift.RawRepresentable {}
extension KustomerChat.KustomerConfigurationError : Swift.Equatable {}
extension KustomerChat.KustomerConfigurationError : Swift.Hashable {}
extension KustomerChat.KUSConversationLockReason : Swift.Equatable {}
extension KustomerChat.KUSConversationLockReason : Swift.Hashable {}
extension KustomerChat.KUSConversationLockReason : Swift.RawRepresentable {}
extension KustomerChat.KnowledgeBaseDocumentType : Swift.Equatable {}
extension KustomerChat.KnowledgeBaseDocumentType : Swift.Hashable {}
extension KustomerChat.KnowledgeBaseDocumentType : Swift.RawRepresentable {}
extension KustomerChat.KustomerOffhoursDisplay : Swift.Equatable {}
extension KustomerChat.KustomerOffhoursDisplay : Swift.Hashable {}
extension KustomerChat.KustomerOffhoursDisplay : Swift.RawRepresentable {}
extension KustomerChat.KnowledgeBaseCategoryViewMode : Swift.Equatable {}
extension KustomerChat.KnowledgeBaseCategoryViewMode : Swift.Hashable {}
extension KustomerChat.KUSChatMessageStatus : Swift.Equatable {}
extension KustomerChat.KUSChatMessageStatus : Swift.Hashable {}
extension KustomerChat.KUSMessageTemplateType : Swift.Equatable {}
extension KustomerChat.KUSMessageTemplateType : Swift.Hashable {}
extension KustomerChat.KUSMessageTemplateType : Swift.RawRepresentable {}
extension KustomerChat.PresenceType : Swift.Equatable {}
extension KustomerChat.PresenceType : Swift.Hashable {}
extension KustomerChat.KustomerDisplayMode : Swift.Equatable {}
extension KustomerChat.KustomerDisplayMode : Swift.Hashable {}
extension KustomerChat.KUSConversationStatus : Swift.Equatable {}
extension KustomerChat.KUSConversationStatus : Swift.Hashable {}
extension KustomerChat.KustomerLogType : Swift.Equatable {}
extension KustomerChat.KustomerLogType : Swift.Hashable {}
extension KustomerChat.KustomerLogType : Swift.RawRepresentable {}
extension KustomerChat.PushEnvironment : Swift.Equatable {}
extension KustomerChat.PushEnvironment : Swift.Hashable {}
extension KustomerChat.PushEnvironment : Swift.RawRepresentable {}
extension KustomerChat.KBSurveyRating : Swift.Equatable {}
extension KustomerChat.KBSurveyRating : Swift.Hashable {}
extension KustomerChat.KBSurveyRating : Swift.RawRepresentable {}
extension KustomerChat.KUSInitialMessageDirection : Swift.Equatable {}
extension KustomerChat.KUSInitialMessageDirection : Swift.Hashable {}
extension KustomerChat.KUSInitialMessageDirection : Swift.RawRepresentable {}
