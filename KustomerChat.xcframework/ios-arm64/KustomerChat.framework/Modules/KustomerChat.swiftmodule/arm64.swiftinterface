// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4.2 (swiftlang-1205.0.28.2 clang-1205.0.19.57)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name KustomerChat
import AVFoundation
import CommonCrypto
import CoreData
import CoreGraphics
import CoreImage
import Dispatch
import Foundation
@_exported import KustomerChat
import MobileCoreServices
import OSLog
import PubNub
import QuickLook
import SafariServices
import Swift
import SystemConfiguration
import UIKit.UIGeometry
import UIKit
import UserNotifications
import WebKit
import os.log
import os
@_hasMissingDesignatedInitializers public class KUSUser : Swift.CustomStringConvertible {
  public var id: Swift.String
  public var displayName: Swift.String?
  public var avatarUrl: Swift.String?
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ConnectionProvider {
  public static let shared: KustomerChat.ConnectionProvider
  public func reconnect()
  public var status: KustomerChat.KustomerConnectionStatus {
    get
  }
  public var listeners: [Swift.String : KustomerChat.KUSConnectionListener]
  public func addListener(_ listener: KustomerChat.KUSConnectionListener) -> Swift.String
  public func removeListener(_ uuid: Swift.String)
  public func removeAllListeners()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KUSCustomer : Swift.CustomStringConvertible {
  public var id: Swift.String
  public var description: Swift.String {
    get
  }
  @objc deinit
}
public enum KustomerLanguage : Swift.String {
  case af
  case sq
  case ar
  case ar_eg
  case ar_ma
  case be
  case bs
  case bg
  case ca
  case hr
  case cs
  case da
  case nl
  case en_ca
  case en_gb
  case en_us
  case et
  case fil
  case fr
  case fr_ca
  case fr_ma
  case ka
  case de
  case el
  case he
  case hi
  case hu
  case `is`
  case id
  case it
  case ja
  case kk
  case ky
  case ko
  case lv
  case lt
  case no
  case fa
  case pl
  case br
  case pt
  case pa
  case ro
  case ru
  case sr
  case sr_me
  case zh_cn
  case sk
  case sl
  case es
  case es_ar
  case es_pa
  case es_pe
  case es_es
  case sw
  case sv
  case th
  case zh_tw
  case tr
  case tw
  case uk
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KustomerAssetLanguage : Swift.String {
  case af
  case am
  case ar
  case az
  case be
  case bg
  case bn
  case bs
  case ca
  case ceb
  case co
  case cs
  case cy
  case da
  case de
  case el
  case en
  case eo
  case es
  case et
  case eu
  case fa
  case fi
  case fr
  case fy
  case ga
  case gd
  case gl
  case gu
  case ha
  case haw
  case he
  case hi
  case hmn
  case hr
  case ht
  case hu
  case hy
  case id
  case ig
  case `is`
  case it
  case iw
  case ja
  case jw
  case ka
  case kk
  case km
  case kn
  case ko
  case ku
  case ky
  case la
  case lb
  case lo
  case lt
  case lv
  case mg
  case mi
  case mk
  case ml
  case mn
  case mr
  case ms
  case mt
  case my
  case ne
  case nl
  case no
  case ny
  case or
  case pa
  case pl
  case ps
  case pt
  case ro
  case ru
  case rw
  case sd
  case si
  case sk
  case sl
  case sm
  case sn
  case so
  case sq
  case sr
  case st
  case su
  case sv
  case sw
  case ta
  case te
  case tg
  case th
  case tk
  case tl
  case tr
  case tt
  case ug
  case uk
  case ur
  case uz
  case vi
  case xh
  case yi
  case yo
  case zh
  case zh_CN
  case zh_TW
  case zu
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias NetworkOperationCompletion = (Swift.Result<KustomerChat.NetworkOperationResponse, KustomerChat.NetworkError>) -> Swift.Void
public typealias NetworkDispatchCompletion = (Foundation.Data?, Foundation.HTTPURLResponse?, Swift.Error?) -> Swift.Void
@objc @_inheritsConvenienceInitializers public class PushProvider : ObjectiveC.NSObject, UserNotifications.UNUserNotificationCenterDelegate {
  public static let shared: KustomerChat.PushProvider
  public var deviceToken: Foundation.Data? {
    get
  }
  public var deviceTokenString: Swift.String? {
    get
  }
  public func deregisterCurrentDeviceForPushNotifications(_ completion: @escaping ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void))
  public func didFailToRegisterForRemoteNotifications(error: Swift.Error)
  public func didRegisterForRemoteNotifications(deviceToken: Foundation.Data)
  public func requestAuthorizationForPush()
  public func listLivePushChannelRegistrations(completion: ((Swift.Result<[Swift.String], KustomerChat.KError>) -> Swift.Void)? = nil)
  @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, didReceive response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)
  @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, willPresent notification: UserNotifications.UNNotification, withCompletionHandler completionHandler: @escaping (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
  @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, openSettingsFor notification: UserNotifications.UNNotification?)
  public func notificationIsFromKustomer(_ notification: UserNotifications.UNNotification) -> Swift.Bool
  public func notificationIsFromKustomer(threadIdentifier: Swift.String?) -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public struct KnowledgeBaseProvider {
  public func getRootCategory(lang: Swift.String, knowledgeBaseID: Swift.String?, completion: @escaping KustomerChat.KustomerCompletion<KustomerChat.KnowledgeBaseCategory>)
  public func getCategory(by id: Swift.String, childrenLimit: Swift.Int, lang: Swift.String, knowledgeBaseID: Swift.String?, completion: @escaping KustomerChat.KustomerCompletion<KustomerChat.KnowledgeBaseResponse>)
  public func searchArticles(term: Swift.String, page: Swift.Int, pageSize: Swift.Int, lang: Swift.String, completion: @escaping KustomerChat.KustomerCompletion<[KustomerChat.KnowledgeBaseArticle]>)
  public func getArticle(by id: Swift.String, lang: Swift.String, knowledgeBaseID: Swift.String?, completion: @escaping KustomerChat.KustomerCompletion<KustomerChat.KnowledgeBaseArticle>)
}
public protocol CoordinatorDelegate : AnyObject {
  func coordinatorWillDisappear(_ coordinator: KustomerChat.Coordinator)
  func coordinatorWillAppear(_ coordinator: KustomerChat.Coordinator)
  func coordinatorDidAppear(_ coordinator: KustomerChat.Coordinator)
  func coordinatorDidDisappear(_ coordinator: KustomerChat.Coordinator)
  func coordinatorDidHide(_ coordinator: KustomerChat.Coordinator)
}
extension CoordinatorDelegate {
  public func coordinatorWillDisappear(_ coordinator: KustomerChat.Coordinator)
  public func coordinatorWillAppear(_ coordinator: KustomerChat.Coordinator)
  public func coordinatorDidAppear(_ coordinator: KustomerChat.Coordinator)
  public func coordinatorDidDisappear(_ coordinator: KustomerChat.Coordinator)
  public func coordinatorDidHide(_ coordinator: KustomerChat.Coordinator)
}
public struct KUSAlertSettings {
}
public typealias KUSAlertCompletionHandler = ((KustomerChat.KUSAlertResult) -> Swift.Void)
public enum KUSAlertButtonType {
  case cancel(title: Swift.String)
  case other(title: Swift.String)
  case preferred(title: Swift.String)
  case destructive(title: Swift.String)
  case textField(text: Swift.String, placeholder: Swift.String?)
}
public enum KUSAlertResult {
  case cancel
  case other(inputText: [Swift.String])
}
@_hasMissingDesignatedInitializers public class KUSAlertManager {
  @objc deinit
}
public struct KUSAlertInfo {
}
@objc public class KUSSWAlert : ObjectiveC.NSObject, UIKit.UIAlertViewDelegate {
  public static var lastTextEntered: [Swift.String?]
  public static func showAlert(_ title: Swift.String?, message: Swift.String?, buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil)
  public init(title: Swift.String?, message: Swift.String?)
  public func setCancelAction(_ buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil) -> KustomerChat.KUSSWAlert
  public func setCancelAction(_ buttonTitle: Swift.String) -> KustomerChat.KUSSWAlert
  public func addAction(_ buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil) -> KustomerChat.KUSSWAlert
  public func addDestructiveAction(_ buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil) -> KustomerChat.KUSSWAlert
  public func addDefaultAction(_ buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil) -> KustomerChat.KUSSWAlert
  public func addAction(_ buttonTitle: Swift.String) -> KustomerChat.KUSSWAlert
  public func addTextField(_ text: Swift.String, placeholder: Swift.String? = nil) -> KustomerChat.KUSSWAlert
  public func addTextField(_ text: Swift.String) -> KustomerChat.KUSSWAlert
  public func show()
  public func showActionSheet()
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ChatProvider {
  public static let shared: KustomerChat.ChatProvider
  final public var listeners: [Swift.String : KustomerChat.KUSChatListener]
  final public func addChatListener(_ listener: KustomerChat.KUSChatListener) -> Swift.String
  final public func removeChatListener(_ uuid: Swift.String)
  final public func removeAllChatListeners()
  final public func listenForTyping(conversationId: Swift.String)
  final public func stopListeningForTyping(conversationId: Swift.String)
  final public func getConversations() -> [KustomerChat.KUSConversation]
  final public func getConversation(conversationId: Swift.String) -> KustomerChat.KUSConversation?
  final public func chatMessages(conversationId: Swift.String) -> [KustomerChat.KUSChatMessage]
  final public func getChatMessages(conversationId: Swift.String, completion: @escaping (Swift.Result<[KustomerChat.KUSChatMessage], KustomerChat.KError>) -> Swift.Void)
  @available(*, deprecated, message: "Use getUnreadCount")
  final public func old_unreadCount() -> Swift.Int
  @available(*, deprecated, message: "Use getUnreadCount")
  final public func unreadCount() -> Swift.Int
  final public func getUnreadCount() -> Swift.Int
  final public func openConversationCount() -> Swift.Int
  @available(*, deprecated, message: "Use customerExists instead")
  final public func currentCustomer() -> KustomerChat.KUSCustomer?
  final public func customerExists() -> Swift.Bool
  final public func getChatSettings() -> KustomerChat.KUSChatSettings
  final public func isChatAvailable() -> Swift.Bool?
  final public func createConversation(firstCustomerMessage text: Swift.String, completion: @escaping ((Swift.Result<(conversation: KustomerChat.KUSConversation, messages: [KustomerChat.KUSChatMessage], customer: KustomerChat.KUSCustomer?), KustomerChat.KError>) -> Swift.Void))
  final public func sendChatMessage(text: Swift.String, conversationId: Swift.String, completion: @escaping ((Swift.Result<(message: KustomerChat.KUSChatMessage, conversation: KustomerChat.KUSConversation), KustomerChat.KError>) -> Swift.Void))
  final public func sendChatMessage(action: KustomerChat.KUSMessageAction, completion _outerCompletion: @escaping (KustomerChat.KUSChatMessage, KustomerChat.KUSConversation) -> Swift.Void)
  final public func sendChatMessage(text: Swift.String, assistant: KustomerChat.KUSAssistant, completion _outerCompletion: @escaping (KustomerChat.KUSChatMessage, KustomerChat.KUSConversation) -> Swift.Void)
  final public func sendChatMessage(mllNode: KustomerChat.KUSMLLNode, completion _outerCompletion: @escaping (KustomerChat.KUSChatMessage, KustomerChat.KUSConversation) -> Swift.Void)
  final public func sendChatMessage(image: UIKit.UIImage, conversationId: Swift.String, completion: @escaping ((KustomerChat.KError?) -> Swift.Void))
  final public func sendChatMessage(fileUrl: Foundation.URL, conversationId: Swift.String, completion: @escaping ((KustomerChat.KError?) -> Swift.Void))
  final public func createAssistant(id: Swift.String, startDialog: Swift.String?, after: @escaping ((KustomerChat.KUSAssistant) -> Swift.Void), error: @escaping ((KustomerChat.KError) -> Swift.Void), afterCreateConversation: ((KustomerChat.KUSConversation) -> Swift.Void)? = { _ in }) -> Swift.String
  final public func endConversation(conversationId: Swift.String, completion: @escaping ((Swift.Result<KustomerChat.KUSConversation, KustomerChat.KError>) -> Swift.Void))
  final public func reloadChatSettings(_ callback: @escaping ((KustomerChat.KError?) -> Swift.Void))
  final public func describeConversation(conversationId: Swift.String, attributes: [Swift.String : Any], _ completion: @escaping ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void))
  final public func describeCurrentCustomer(phone: Swift.String? = nil, email: Swift.String? = nil, phones: [Swift.String]? = nil, emails: [Swift.String]? = nil, facebook: Swift.String? = nil, instagram: Swift.String? = nil, twitter: Swift.String? = nil, linkedIn: Swift.String? = nil, custom: [Swift.String : Any]? = nil, _ completion: ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void)? = nil)
  final public func markRead(conversationId: Swift.String)
  @objc deinit
}
public struct KnowledgeBaseArticle : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseArticleAttributes : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
infix operator ++ : AssignmentPrecedence
public struct KUSKBDeflectResult {
  public var id: Swift.String?
  public var articleOrCategoryId: Swift.String?
  public var type: KustomerChat.KUSKBDeflectResultType?
  public var title: Swift.String?
  public var webLink: Swift.String?
  public var lang: Swift.String?
  public var rawJson: Swift.String?
  public var clickCount: Swift.Int
}
extension KustomerClient {
  @available(*, deprecated)
  final public func triggerHotReloadFromAppDelegate()
  @available(*, deprecated)
  final public func triggerHotReloadFromAppDelegate(completion: @escaping (() -> Swift.Void))
}
@_hasMissingDesignatedInitializers final public class KUSChatAttachment : Swift.CustomStringConvertible {
  final public var id: Swift.String
  final public var conversationId: Swift.String?
  final public var contentType: Swift.String?
  final public var url: Swift.String?
  final public var name: Swift.String?
  final public var chatMessageId: Swift.String?
  final public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class KnowledgeBaseCategoryLoader {
  @objc deinit
}
public class KUSTrackingIdentity : Swift.Decodable {
  public var id: Swift.String?
  public var customerId: Swift.String?
  public var trackingId: Swift.String?
  public var trackingToken: Swift.String?
  public var email: Swift.String?
  public var externalId: Swift.String?
  public var verified: Swift.Bool?
  public var verifiedAt: Foundation.Date?
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date?
  required public init(from decoder: Swift.Decoder)
  @objc deinit
}
public protocol KBCategoryCollectionDataSource : AnyObject {
  var sectionTitle: Swift.String? { get }
  var rows: [KustomerChat.KnowledgeBaseDataRow] { get }
}
@_hasMissingDesignatedInitializers public class Settings {
  public var teamName: Swift.String {
    get
    set
  }
  public var teamIconUrl: Swift.String {
    get
    set
  }
  public var widgetType: Swift.String? {
    get
    set
  }
  public var greeting: Swift.String {
    get
    set
  }
  public var offhoursDisplay: KustomerChat.KustomerOffhoursDisplay {
    get
    set
  }
  public var offhoursMessage: Swift.String {
    get
    set
  }
  public var offhoursImageUrl: Swift.String? {
    get
    set
  }
  public var waitMessage: Swift.String? {
    get
    set
  }
  public var activeAssistant: Swift.String? {
    get
    set
  }
  public var enabled: Swift.Bool? {
    get
    set
  }
  public var didLoadSettingsFirstTime: Swift.Bool {
    get
    set
  }
  public var singleSessionChat: Swift.Bool {
    get
    set
  }
  public var closableChat: Swift.Bool {
    get
    set
  }
  public var noHistory: Swift.Bool {
    get
    set
  }
  public var showTypingIndicatorWeb: Swift.Bool {
    get
    set
  }
  public var showTypingIndicatorCustomerWeb: Swift.Bool {
    get
    set
  }
  public var autoreply: Swift.String {
    get
    set
  }
  public var embedIconUrl: Swift.String {
    get
    set
  }
  public var embedIconColor: Swift.String? {
    get
    set
  }
  public var activeForm: Swift.String? {
    get
    set
  }
  public var campaignsEnabled: Swift.Bool {
    get
    set
  }
  public var pusherAccessKey: Swift.String {
    get
    set
  }
  public var pusherCluster: Swift.String {
    get
    set
  }
  public var volumeControlTimeout: Swift.Int {
    get
    set
  }
  public var volumeControlPromptDelay: Swift.Int {
    get
    set
  }
  public var volumeControlUpfrontWaitThreshold: Swift.Int {
    get
    set
  }
  public var csatLockTime: Swift.Int? {
    get
    set
  }
  public var csatDebounceSendTime: Swift.Int {
    get
    set
  }
  public var volumeControlMode: Swift.String {
    get
    set
  }
  public var volumeControlCustomWaitMessage: Swift.String? {
    get
    set
  }
  public var volumeControlEnabled: Swift.Bool {
    get
    set
  }
  public var volumeControlMarkDoneAfterTimeout: Swift.Bool {
    get
    set
  }
  public var volumeControlUseDynamicWaitMessage: Swift.Bool {
    get
    set
  }
  public var volumeControlHideWaitOption: Swift.Bool {
    get
    set
  }
  public var showEmailInputBanner: Swift.Bool {
    get
    set
  }
  public var csatInboundMessagesOverride: Swift.Bool {
    get
    set
  }
  public var csatOutboundMessagesOverride: Swift.Bool {
    get
    set
  }
  public var volumeControlFollowUpChannels: [Swift.String] {
    get
    set
  }
  public var shouldDisableAttachments: Swift.Bool {
    get
    set
  }
  @objc deinit
}
public protocol KUSURLConvertible {
  func kus_asURL() throws -> Foundation.URL
}
extension String : KustomerChat.KUSURLConvertible {
  public func kus_asURL() throws -> Foundation.URL
}
extension URL : KustomerChat.KUSURLConvertible {
  public func kus_asURL() throws -> Foundation.URL
}
extension URLComponents : KustomerChat.KUSURLConvertible {
  public func kus_asURL() throws -> Foundation.URL
}
public typealias KustomerCompletion<T> = (Swift.Result<T, KustomerChat.KustomerError>) -> Swift.Void
public enum KustomerClientStatus {
  case uninitialized
  case configured
  case configurationError(error: KustomerChat.KError?)
  case starting
  case started
  case stopped
  case connected
  case disconnected
}
public protocol KUSConnectionListener {
  func onPubNubConnectionStatusChange(status: KustomerChat.KustomerConnectionStatus)
}
extension KUSConnectionListener {
  public func onPubNubConnectionStatusChange(status: KustomerChat.KustomerConnectionStatus)
}
public let Kustomer: KustomerChat.KustomerClient
public typealias KUSPNTtoken = Swift.UInt64
public enum KUSKBDeflectResultType : Swift.String {
  case article
  case category
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol CoordinatorCreator : AnyObject {
  var currentCoordinator: KustomerChat.Coordinator? { get set }
  static func make() -> KustomerChat.Coordinator
}
public struct KnowledgeBase : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseAttributes : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
final public class KUSKBArticle : KustomerChat.KUSKBItemBase, Swift.CustomStringConvertible {
  final public var id: Swift.String?
  final public var htmlBody: Swift.String?
  final public var title: Swift.String?
  final public var metaDescription: Swift.String?
  final public var rawJson: Swift.String?
  final public var hashIdentifier: Swift.String?
  final public var versionId: Swift.String?
  final public var slug: Swift.String?
  final public var lang: Swift.String?
  public init()
  final public var description: Swift.String {
    get
  }
  @objc deinit
}
public enum KUSSentByType : Swift.String {
  case User
  case Customer
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class KBArticleCoordinator : KustomerChat.DataCoordinatorCreator, KustomerChat.Coordinator {
  weak final public var delegate: KustomerChat.CoordinatorDelegate?
  public typealias KnowledgeBaseArticleData = (article: KustomerChat.KnowledgeBaseArticle?, id: Swift.String)
  public typealias Value = KustomerChat.KBArticleCoordinator.KnowledgeBaseArticleData
  final public var view: UIKit.UIViewController {
    get
  }
  final public var navigationController: UIKit.UINavigationController?
  final public var currentCoordinator: KustomerChat.Coordinator?
  public static func make(value: KustomerChat.KBArticleCoordinator.KnowledgeBaseArticleData) -> KustomerChat.Coordinator
  final public func show(in navigationController: UIKit.UINavigationController?)
  @objc deinit
}
public class KustomerOptions {
  public init()
  public var enableUI: Swift.Bool
  public var showInAppNotifications: Swift.Bool
  public var language: KustomerChat.KustomerLanguage?
  public var debugMode: Swift.Bool
  @available(*, deprecated, message: "Pass a reference to the presenting view controller in the appropiate Kustomer API")
  public var hostViewController: UIKit.UIViewController?
  public var activeAssistant: KustomerChat.ActiveAssistantOptions
  public var disablePush: Swift.Bool
  public var pushBundleId: Swift.String {
    get
    set
  }
  public var pushEnvironment: KustomerChat.PushEnvironment
  public var hideNewConversationButtonInClosedChat: Swift.Bool
  public var showAnimationFor5StarCSATRatings: Swift.Bool
  public var onShow: (() -> Swift.Void)?
  public var onDismiss: (() -> Swift.Void)?
  @available(*, deprecated, message: "Use onShow instead")
  public var onViewDidAppear: ((Swift.Bool) -> Swift.Void)?
  @available(*, deprecated, message: "Use onShow instead")
  public var onViewWillAppear: ((Swift.Bool) -> Swift.Void)?
  @available(*, deprecated, message: "Use onDismiss instead")
  public var onViewWillDisappear: ((Swift.Bool) -> Swift.Void)?
  @available(*, deprecated, message: "Use onDismiss instead")
  public var onViewDidDisappear: ((Swift.Bool) -> Swift.Void)?
  public var hostDomain: Swift.String?
  public var businessScheduleId: Swift.String?
  @available(*, deprecated, message: "Use `brandId` instead whenever possible. This will override the brand id's knowledge base id.")
  public var knowledgeBaseID: Swift.String?
  public var brandId: Swift.String? {
    get
    set
  }
  public var logLevels: [KustomerChat.KustomerLogType]
  public var hideNewConversationButton: Swift.Bool
  public var hideKbArticleShare: Swift.Bool
  public var flags: Swift.String?
  @KustomerChat.KUSClamping public var messageAttachmentLocalCacheMaximumSizeInBytes: Swift.Int {
    get
    set
    _modify
  }
  public var hideHistoryNavigation: Swift.Bool
  @available(*, deprecated)
  public var orgSecret: Swift.String?
  @objc deinit
}
public enum ActiveAssistantOptions {
  case none
  case orgDefault
  case withId(Swift.String)
}
public enum KURLEncoding {
  case `default`
  case queryString
  case httpBody
  case jsonEncoding(encodable: Swift.Encodable, encoder: Foundation.JSONEncoder)
}
public struct KJSONParameterEncoding {
  public func encode(_ request: Foundation.URLRequest, with parameters: KustomerChat.KParameters?) throws -> Foundation.URLRequest
}
public protocol DataCoordinatorCreator {
  associatedtype Value
  static func make(value: Self.Value) -> KustomerChat.Coordinator
}
public protocol KUSKBItemBase : Swift.CustomStringConvertible {
  var id: Swift.String? { get set }
  var htmlBody: Swift.String? { get set }
  var title: Swift.String? { get set }
  var metaDescription: Swift.String? { get set }
  var rawJson: Swift.String? { get set }
  var description: Swift.String { get }
}
extension KUSKBItemBase {
  public func completeObject() -> [Swift.String : Any]?
}
@_hasMissingDesignatedInitializers public class KBCategoryBridge : KustomerChat.KUSKBItemBase {
  public var id: Swift.String?
  public var htmlBody: Swift.String?
  public var title: Swift.String?
  public var metaDescription: Swift.String?
  public var rawJson: Swift.String?
  public var isRoot: Swift.Bool
  public var slug: Swift.String?
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KBArticleBridge : KustomerChat.KUSKBItemBase {
  public var id: Swift.String?
  public var htmlBody: Swift.String?
  public var title: Swift.String?
  public var metaDescription: Swift.String?
  public var rawJson: Swift.String?
  public var hashIdentifier: Swift.String?
  public var slug: Swift.String?
  public var lang: Swift.String?
  public var description: Swift.String {
    get
  }
  @objc deinit
}
public struct KnowledgeBaseSurvey : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@propertyWrapper public struct KUSClamping<Value> : Swift.Comparable where Value : Swift.Comparable {
  public static func < (lhs: KustomerChat.KUSClamping<Value>, rhs: KustomerChat.KUSClamping<Value>) -> Swift.Bool
  public var value: Value
  public let range: Swift.ClosedRange<Value>
  public init(wrappedValue value: Value, _ range: Swift.ClosedRange<Value>)
  public var wrappedValue: Value {
    get
    set
  }
  public static func == (a: KustomerChat.KUSClamping<Value>, b: KustomerChat.KUSClamping<Value>) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class KBCategoryCoordinator : KustomerChat.DataCoordinatorCreator, KustomerChat.Coordinator {
  public typealias Value = KustomerChat.KnowledgeBaseCategoryData
  weak final public var delegate: KustomerChat.CoordinatorDelegate?
  final public var view: UIKit.UIViewController {
    get
  }
  weak final public var navigationController: UIKit.UINavigationController?
  final public var currentCoordinator: KustomerChat.Coordinator?
  public static func make(value: KustomerChat.KnowledgeBaseCategoryData) -> KustomerChat.Coordinator
  public static func make() -> KustomerChat.Coordinator
  final public func show(in navigationController: UIKit.UINavigationController?)
  @objc deinit
}
public enum KnowledgeBaseDataRow {
  case category(category: KustomerChat.KnowledgeBaseCategory, didSelect: ((KustomerChat.KnowledgeBaseCategory) -> Swift.Void)?)
  case article(article: KustomerChat.KnowledgeBaseArticle, didSelect: ((KustomerChat.KnowledgeBaseArticle) -> Swift.Void)?)
}
@objc final public class ConfettiView : UIKit.UIView {
  @objc dynamic public init()
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  final public func emit(with contents: [KustomerChat.ConfettiView.Content], for duration: Foundation.TimeInterval = 3.0)
  @objc override final public func willMove(toSuperview newSuperview: UIKit.UIView?)
  public enum Content {
    public enum Shape {
      case circle
      case triangle
      case square
      case custom(CoreGraphics.CGPath)
    }
    case shape(KustomerChat.ConfettiView.Content.Shape, UIKit.UIColor)
    case image(UIKit.UIImage, UIKit.UIColor?)
    case text(Swift.String)
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
extension ConfettiView : QuartzCore.CAAnimationDelegate {
  @objc final public func animationDidStop(_ animation: QuartzCore.CAAnimation, finished flag: Swift.Bool)
}
@objc @_inheritsConvenienceInitializers open class NextGrowingTextView : UIKit.UIScrollView {
  @_hasMissingDesignatedInitializers open class Delegates {
    open var willChangeHeight: (CoreGraphics.CGFloat) -> Swift.Void
    open var didChangeHeight: (CoreGraphics.CGFloat) -> Swift.Void
    @objc deinit
  }
  open var delegates: KustomerChat.NextGrowingTextView.Delegates
  open var textView: UIKit.UITextView {
    get
  }
  open var minNumberOfLines: Swift.Int {
    get
    set
  }
  open var maxNumberOfLines: Swift.Int {
    get
    set
  }
  @available(*, deprecated, message: "Use isAutomaticScrollToBottomEnabled")
  open var disableAutomaticScrollToBottom: Swift.Bool {
    get
  }
  open var isAutomaticScrollToBottomEnabled: Swift.Bool
  open var placeholderAttributedText: Foundation.NSAttributedString? {
    get
    set
  }
  @objc override dynamic open var inputView: UIKit.UIView? {
    @objc get
    @objc set
  }
  @objc override dynamic open var isFirstResponder: Swift.Bool {
    @objc get
  }
  @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @objc override dynamic open var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open func layoutSubviews()
  @objc override dynamic open func reloadInputViews()
  @objc deinit
}
public enum KustomerConnectionStatus : Swift.String {
  case connecting
  case connected
  case reconnecting
  case disconnected
  case disconnectedUnexpectedly
  public var isActive: Swift.Bool {
    get
  }
  public var isConnected: Swift.Bool {
    get
  }
  public var ableToTryReconnecting: Swift.Bool {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol KUSChatListener {
  func onChatMessageReceived(conversationId: Swift.String, chatMessage: KustomerChat.KUSChatMessage)
  func onConversationEnded(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  func onConversationReOpened(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  func onOpenConversationCountChange(count: Swift.Int)
  func onConversationCreated(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  func onUnreadCountChange(count: Swift.Int)
  func onUserJoined(conversationId: Swift.String, user: KustomerChat.KUSUser)
  func onUserIsTyping(conversationId: Swift.String, user: KustomerChat.KUSUser, timetoken: KustomerChat.KUSPNTtoken?)
  func onUserStopsTyping(conversationId: Swift.String, user: KustomerChat.KUSUser, timetoken: KustomerChat.KUSPNTtoken?)
  func onConversationMerge(sourceConversation: KustomerChat.KUSConversation, targetConversation: KustomerChat.KUSConversation)
}
extension KUSChatListener {
  public func onChatMessageReceived(conversationId: Swift.String, chatMessage: KustomerChat.KUSChatMessage)
  public func onConversationEnded(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  public func onConversationReOpened(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  public func onOpenConversationCountChange(count: Swift.Int)
  public func onConversationCreated(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  public func onUnreadCountChange(count: Swift.Int)
  public func onUserJoined(conversationId: Swift.String, user: KustomerChat.KUSUser)
  public func onUserIsTyping(conversationId: Swift.String, user: KustomerChat.KUSUser, timetoken: KustomerChat.KUSPNTtoken?)
  public func onUserStopsTyping(conversationId: Swift.String, user: KustomerChat.KUSUser, timetoken: KustomerChat.KUSPNTtoken?)
  public func onConversationMerge(sourceConversation: KustomerChat.KUSConversation, targetConversation: KustomerChat.KUSConversation)
}
public struct KnowledgeBaseCategoryData {
}
public struct KUSMessageAction {
  public var displayText: Swift.String
  public var value: Swift.String
  public var rawJson: Swift.String?
}
public struct KUSMLLNode {
  public var displayText: Swift.String?
  public var value: Swift.String?
  public var children: [KustomerChat.KUSMLLNode]? {
    get
  }
}
extension UIColor {
}
@available(*, unavailable, renamed: "Notification.Name.KUS_reachabilityChanged")
public let KUSReachabilityChangedNotification: Foundation.NSNotification.Name
extension NSNotification.Name {
  public static let KUSReachabilityChanged: Foundation.Notification.Name
}
@_hasMissingDesignatedInitializers public class KUSConversation : Swift.CustomStringConvertible {
  public var id: Swift.String?
  public var createdAt: Foundation.Date?
  public var lastMessageAt: Foundation.Date?
  public var status: KustomerChat.KUSConversationStatus?
  public var brandId: Swift.String?
  public var lockedAt: Foundation.Date?
  public var lockedByCustomer: Swift.Bool?
  public var lockReason: KustomerChat.KUSConversationLockReason?
  public var preview: Swift.String?
  public var respondingUserIds: [Swift.String?]?
  public var unreadMessageCount: Swift.Int?
  public var users: [KustomerChat.KUSUser]?
  public var localUuid: Swift.String?
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class KBProvider {
  public static let shared: KustomerChat.KBProvider
  @available(*, deprecated, message: "Please use KustomerClient.shared.kbProvider.getRootCategory")
  final public func getEntriesForRoot(completion: @escaping ((Swift.Result<[KustomerChat.KUSKBItemBase], KustomerChat.KError>) -> Swift.Void))
  @available(*, deprecated, message: "Please use KustomerClient.shared.kbProvider.searchArticles")
  final public func getEntries(parentCategoryId: Swift.String?, search: Swift.String? = nil, completion: @escaping ((Swift.Result<[KustomerChat.KUSKBItemBase], KustomerChat.KError>) -> Swift.Void))
  @available(*, deprecated, message: "Please use KustomerClient.shared.kbProvider.getCategory")
  final public func getCategory(id: Swift.String, completion: @escaping ((Swift.Result<KustomerChat.KUSKBCategory, KustomerChat.KError>) -> Swift.Void))
  @available(*, deprecated, message: "Please use KustomerClient.shared.kbProvider.getArticle")
  final public func getArticle(id: Swift.String, completion: @escaping ((Swift.Result<KustomerChat.KUSKBArticle, KustomerChat.KError>) -> Swift.Void))
  @objc deinit
}
public struct NetworkDispatcher {
  public var session: Foundation.URLSession
  public func dispatchRequest(_ request: Foundation.URLRequest, completion: @escaping KustomerChat.NetworkDispatchCompletion) -> Foundation.URLSessionDataTask
}
extension NetworkDispatcher {
  public static func defaultSessionConfiguration() -> Foundation.URLSessionConfiguration
  public static func additionalHeaders() -> [Swift.AnyHashable : Any]?
}
public enum KUSChatMessageDirection : Swift.String {
  case inbound
  case outbound
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class EventBroadcaster {
  @objc deinit
}
extension KustomerUI.Color {
  public static var activeLinkColor: UIKit.UIColor
  public static var chatAvatarBackground: UIKit.UIColor
  public static var chatAvatarInitials: UIKit.UIColor
  public static var chatHeaderBackground: UIKit.UIColor
  public static var chatHeaderBackgroundWhenInAssistant: UIKit.UIColor
  public static var chatInputBarBackground: UIKit.UIColor
  public static var chatSearchBarBackground: UIKit.UIColor
  public static var chatTableBackground: UIKit.UIColor
  public static var chatTextInputBackground: UIKit.UIColor
  public static var chatNewConversationButton: UIKit.UIColor
  public static var chatNewConversationButtonText: UIKit.UIColor
  public static var chatEndedRowText: UIKit.UIColor
  public static var chatEndedRowLine: UIKit.UIColor
  public static var csatText: UIKit.UIColor
  public static var csatCommentBoxBackground: UIKit.UIColor
  public static var csatCommentBoxOutline: UIKit.UIColor
  public static var csatSlideUpBackground: UIKit.UIColor
  public static var historyBackground: UIKit.UIColor
  public static var historyBadgeBackground: UIKit.UIColor
  public static var historyBadgeText: UIKit.UIColor
  public static var historyEmptyStateBackground: UIKit.UIColor
  public static var historyHeaderBackground: UIKit.UIColor
  public static var historyHeaderSeparator: UIKit.UIColor
  public static var historyNewChatButton: UIKit.UIColor
  public static var historyNewChatButtonText: UIKit.UIColor
  public static var historyRowBackground: UIKit.UIColor
  public static var historySearchBarBackground: UIKit.UIColor
  public static var historyTitleColor: UIKit.UIColor
  public static var incomingMessageBubble: UIKit.UIColor
  public static var incomingMessageText: UIKit.UIColor
  public static var loadingNavigationHeaderSeparator: UIKit.UIColor
  public static var loadingViewBackground: UIKit.UIColor
  public static var messageButtonBackground: UIKit.UIColor
  public static var messageButtonText: UIKit.UIColor
  public static var messageUrlLinkOnAgentBubble: UIKit.UIColor
  public static var messageUrlLinkOnCustomerBubble: UIKit.UIColor
  public static var messageLinkInHistoryList: UIKit.UIColor
  public static var messagesBackground: UIKit.UIColor
  public static var navigationBarButton: UIKit.UIColor
  public static var outgoingMessageBubble: UIKit.UIColor
  public static var outgoingMessageText: UIKit.UIColor
  public static var tabBarBackground: UIKit.UIColor
  public static var tabBarItemColor: UIKit.UIColor
  public static var tabBarUnselectedItemColor: UIKit.UIColor
  public static var waitingLabelHeaderText: UIKit.UIColor
  public static var kbBrowseBackground: UIKit.UIColor
  public static var kbBrowseSeparator: UIKit.UIColor?
  public static var kbLoadingProgressTintColor: UIKit.UIColor?
  public static var kbLoadingTintColor: UIKit.UIColor?
  public static var kobjectButton: UIKit.UIColor?
  public static var kobjectButtonText: UIKit.UIColor?
  public static var kbBrowseRowTitle: UIKit.UIColor?
  public static var kbBrowseRowSubtitle: UIKit.UIColor?
  public static var kbBrowseCategoryDescriptionText: UIKit.UIColor?
  public static var kbBrowseIconTint: UIKit.UIColor?
  public static var kbHeader: UIKit.UIColor
  public static var kbHeaderText: UIKit.UIColor
  public static var kbHeaderTint: UIKit.UIColor
  public static var kbArticleBackgroundLight: UIKit.UIColor
  public static var kbArticleBackgroundDark: UIKit.UIColor
  public static var actionButtonBorder: UIKit.UIColor
  public static var actionButtonText: UIKit.UIColor
  public static var actionButtonBackground: UIKit.UIColor
  public static var chatMllMenuOpenBackdrop: UIKit.UIColor
  public static var mllOptionText: UIKit.UIColor
  public static var mllMenuTitleText: UIKit.UIColor
  public static var mllMenuBackTint: UIKit.UIColor
  public static var quickActionButton: UIKit.UIColor
  public static var quickActionButtonText: UIKit.UIColor
  public static var sendChatMessageButton: UIKit.UIColor
  public static var noInternetBannerBackground: UIKit.UIColor
  public static var noInternetBannerText: UIKit.UIColor
}
public protocol Coordinator : AnyObject {
  var delegate: KustomerChat.CoordinatorDelegate? { get set }
  var view: UIKit.UIViewController { get }
  var navigationController: UIKit.UINavigationController? { get set }
  func show(in navigationController: UIKit.UINavigationController?)
  func present(in controller: UIKit.UIViewController)
}
extension Coordinator {
  public func show(in navigationController: UIKit.UINavigationController?)
  public func present(in controller: UIKit.UIViewController)
}
public enum KustomerConfigurationError : Swift.Error {
  case notEnoughDiskSpace
  public static func == (a: KustomerChat.KustomerConfigurationError, b: KustomerChat.KustomerConfigurationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension KustomerConfigurationError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum KUSConversationLockReason : Swift.String {
  case customer_ended
  case user_ended
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias KHTTPHeaders = [Swift.String : Swift.String]
public typealias KParameters = [Swift.String : Any]
public enum KHTTPMethod : Swift.String {
  case GET
  case POST
  case PUT
  case PATCH
  case DELETE
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HTTPTask {
  case requestPlain
  case requestQueryParameters(KustomerChat.KParameters)
  case requestBodyParameters(KustomerChat.KParameters)
  case requestJSONEncodable(Swift.Encodable)
  case requestCompositeBodyParameters(KustomerChat.KParameters, urlParameters: [Swift.String : Any])
}
public enum KnowledgeBaseDocumentType : Swift.String, Swift.Decodable {
  case article, category
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KBDocument : Swift.Decodable {
  case article(KustomerChat.KnowledgeBaseArticle)
  case category(KustomerChat.KnowledgeBaseCategory)
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseResponse : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseCategory : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseCategoryAttributes : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public class KUSChatSettings {
  public init(userDefaults: Foundation.UserDefaults)
  public var dictionaryRepresentation: [Swift.String : Any] {
    get
  }
  @objc deinit
}
public enum KustomerOffhoursDisplay : Swift.String {
  case none
  case offline
  case online
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KnowledgeBaseCategoryViewMode : Swift.CaseIterable {
  case rootCategory
  case subCategory
  public static func == (a: KustomerChat.KnowledgeBaseCategoryViewMode, b: KustomerChat.KnowledgeBaseCategoryViewMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [KustomerChat.KnowledgeBaseCategoryViewMode]
  public static var allCases: [KustomerChat.KnowledgeBaseCategoryViewMode] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public enum KUSChatMessageStatus {
  case success
  case error
  case sending
  case cancelled
  public static func fromString(_ s: Swift.String?) -> KustomerChat.KUSChatMessageStatus
  public static func == (a: KustomerChat.KUSChatMessageStatus, b: KustomerChat.KUSChatMessageStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum KUSMessageTemplateType : Swift.String {
  case quickReplies
  case mll
  case deflection
  case text
  case list
  case none
  public static func fromString(_ s: Swift.String?) -> KustomerChat.KUSMessageTemplateType
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KError : Swift.Error {
  case named(Swift.String)
  case generic(Swift.Error)
  case alamofire(KustomerChat.KUSAFError)
  case api(details: [Any]?)
  case notEnoughDiskSpace
  case noAPSEnvironmentEntitlement
  case invalidDeviceToken
  case pushRegistrationNotNeededNoCustomerIPC
  case noDeviceToken
  case identificationFailed(Swift.String)
  case loginValidationError(error: Swift.String)
  case channelGroupNameNotFound
  case invalidJwt
  case alreadyIdentifiedWithExternalId(externalId: Swift.String)
  case alreadyIdentifiedWithEmail(email: Swift.String)
  case networkErrorLoadingSettings(KustomerChat.KustomerError)
  case noPubNubClient
  case couldNotDeregisterPush
  case couldNotDeregisterPushBecause(Swift.Error)
  case couldNotDeregisterPushBecauseOf(Swift.String)
  case attachmentTooLarge
  case localFileURLExpired
  case localFileURLHasNoData
  case unknownLanguageCode(Swift.String)
  case describe(details: [Any]?)
  case describeUnknownParameter(parameter: Swift.String, details: [Any]?)
  case describeParameterWrongType(parameter: Swift.String, details: [Any]?)
  case describeNoParamtersSpecified
  case describeCustomerDateParametersNotSupported
  case describeNotAvailableForLocalCustomer
  case describeNotSignedInAsThatCustomerId
  case describeCurrentCustomerIsAnonymous
  case kbNetworkError
  case kbArticleIdNotFound
  case kbCategoryIdNotFound
  case localDataStoreError
  case kbNoParentCategoryIdSpecified
  case invalidConversationId
  case malformedConversationId
  case unauthorizedConversationId
  case genericOpenConversationError(details: Swift.String)
  case couldNotCreateSession
  case cancelledMessageCreateDataRequest
  case internetOffline
  case invalidAssistantId
  case noInternetAvailableAndNoCachedChatAssistantFound
  case couldNotReadLocalFile
  case httpAttachmentUploadWasCancelled
  case invalidBusinessScheduleId
  case invalidBrandId
  case chatAvailError(reason: Swift.String)
  case noCustomerMetaChannelName
  case pubsubHistoryLoadError(failed: [Swift.String : KustomerChat.KError])
  case tooManyChannelKeysInHistoricalCustomerEvents
  case couldNotLoadMessageHistory(error: Swift.Error)
}
extension KError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum KustomerDisplayMode {
  case `default`
  case chatHistory
  case newChat
  case activeChat
  case knowledgeBase
  case knowledgeBaseHome
  case onlyChat
  case onlyKnowledgeBase
  public static func == (a: KustomerChat.KustomerDisplayMode, b: KustomerChat.KustomerDisplayMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct NetworkOperationResponse {
  public let statusCode: Swift.Int?
  public let data: Foundation.Data?
  public let response: Foundation.HTTPURLResponse?
  public let request: Foundation.URLRequest
}
public enum KUSConversationStatus {
  case open
  case ended
  case new
  public static func == (a: KustomerChat.KUSConversationStatus, b: KustomerChat.KUSConversationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum NetworkError : Swift.Error, Foundation.LocalizedError {
  case failed(Swift.Error?)
  case outdated
  case badRequest([Swift.String : Swift.AnyObject]?)
  case serverError([Swift.String : Swift.AnyObject]?)
  case authenticationError
  case requestError(KustomerChat.RequestError)
  case responseError(KustomerChat.ResponseError)
}
public enum RequestError : Swift.Error, Foundation.LocalizedError {
  case invalidRequest(Swift.String)
  case parametersNil
  case parameterEncodingFailed(KustomerChat.ParameterEncodingFailureReason)
}
public enum ParameterEncodingFailureReason {
  case missingUrl
  case jsonEncoding(Swift.Error)
}
public enum ResponseError : Swift.Error, Foundation.LocalizedError {
  case unableToDecode(Swift.DecodingError)
  case noData(Swift.String)
  case noContent
}
public enum KUSAFError : Swift.Error {
  public enum KUSMultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public enum KUSParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case customEncodingFailed(error: Swift.Error)
  }
  public enum KUSParameterEncoderFailureReason {
    public enum KUSRequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(KustomerChat.KUSAFError.KUSParameterEncoderFailureReason.KUSRequiredComponent)
    case encoderFailed(error: Swift.Error)
  }
  public enum KUSResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: Swift.Error)
  }
  public enum KUSResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case decodingFailed(error: Swift.Error)
    case customSerializationFailed(error: Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum KUSServerTrustFailureReason {
    public struct KUSOutput {
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: Swift.Error?)
    case defaultEvaluationFailed(output: KustomerChat.KUSAFError.KUSServerTrustFailureReason.KUSOutput)
    case hostValidationFailed(output: KustomerChat.KUSAFError.KUSServerTrustFailureReason.KUSOutput)
    case revocationCheckFailed
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: Swift.Error)
  }
  public enum KUSURLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: Swift.Error)
  case createURLRequestFailed(error: Swift.Error)
  case downloadedFileMoveFailed(error: Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: KustomerChat.KUSURLConvertible)
  case multipartEncodingFailed(reason: KustomerChat.KUSAFError.KUSMultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: KustomerChat.KUSAFError.KUSParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: KustomerChat.KUSAFError.KUSParameterEncoderFailureReason)
  case requestAdaptationFailed(error: Swift.Error)
  case requestRetryFailed(retryError: Swift.Error, originalError: Swift.Error)
  case responseValidationFailed(reason: KustomerChat.KUSAFError.KUSResponseValidationFailureReason)
  case responseSerializationFailed(reason: KustomerChat.KUSAFError.KUSResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: KustomerChat.KUSAFError.KUSServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: Swift.Error?)
  case sessionTaskFailed(error: Swift.Error)
  case urlRequestValidationFailed(reason: KustomerChat.KUSAFError.KUSURLRequestValidationFailureReason)
  case kustomerAddOnError(error: Foundation.NSError)
}
extension KUSAFError {
}
extension KUSAFError {
}
extension KUSAFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum KustomerLogType : Swift.String {
  case debug
  case warning
  case error
  case info
  case fatal
  @available(*, deprecated)
  case multithreadingWarning
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public let KustomerLogTypeAll: [KustomerChat.KustomerLogType]
@objc @_inheritsConvenienceInitializers final public class KustomerClient : ObjectiveC.NSObject {
  final public var chatProvider: KustomerChat.ChatProvider {
    get
    set
  }
  final public var kbProvider: KustomerChat.KnowledgeBaseProvider {
    get
    set
  }
  final public var pushProvider: KustomerChat.PushProvider
  public static let shared: KustomerChat.KustomerClient
  final public var status: KustomerChat.KustomerClientStatus
  final public var bundle: Foundation.Bundle
  final public let sdkVersion: Swift.String
  final public let sdkVersionBuild: Swift.String
  final public var sdkVersionSemver: Swift.String {
    get
  }
  final public var rootViewController: KustomerChat.SupportTabViewController? {
    get
  }
  final public class var isRunningOnSimulator: Swift.Bool {
    get
  }
  final public func changeActiveAssistant(_ na: KustomerChat.ActiveAssistantOptions)
  @available(*, deprecated, message: "Changing brand ID's on the fly is no longer supported")
  final public func changeBrand(brandId nbid: Swift.String, completion: ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void)? = nil)
  final public func changeBusinessSchedule(scheduleId: Swift.String?, completion: ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void)? = nil)
  final public func getActiveAssistantID() -> Swift.String?
  final public func getActiveAssistantStartDialog() -> Swift.String?
  final public var options: KustomerChat.KustomerOptions {
    get
  }
  final public var orgId: Swift.String
  final public var orgName: Swift.String {
    get
    set
  }
  @available(*, deprecated)
  final public var apiKeyRaw: Swift.String? {
    get
  }
  final public func configure(apiKey: Swift.String, options: KustomerChat.KustomerOptions?, launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]?, completion: ((KustomerChat.KustomerConfigurationError) -> ())? = { _ in }, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line) -> KustomerChat.KustomerClient
  final public func configureUnsafe(apiKey: Swift.String, options: KustomerChat.KustomerOptions?, launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]?, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line) -> KustomerChat.KustomerClient
  final public func isChatAvailable() -> Swift.Bool?
  final public func show(presentingVC: UIKit.UIViewController? = nil)
  final public func show(preferredView: KustomerChat.KustomerDisplayMode, presentingVC: UIKit.UIViewController? = nil)
  final public func openConversation(id: Swift.String, animated: Swift.Bool = true, presentingVC: UIKit.UIViewController? = nil, completion: ((Swift.Result<KustomerChat.KUSConversation, KustomerChat.KError>) -> Swift.Void)? = nil)
  final public func showKbArticle(id: Swift.String, presentingVC: UIKit.UIViewController? = nil)
  final public func showKbCategory(id: Swift.String, presentingVC: UIKit.UIViewController? = nil)
  final public func close(animated: Swift.Bool = true, completion passedCompletion: (() -> Swift.Void)?)
  final public var isVisible: Swift.Bool {
    get
  }
  final public func isLoggedIn(userEmail: Swift.String?, userId: Swift.String?) -> Swift.Bool
  @available(*, deprecated, message: "Use isLoggedIn(userEmail: String?, userId: String?) -> Bool")
  final public func isLoggedIn(userEmail: Swift.String?, userId: Swift.String?, completion: @escaping ((Swift.Result<Swift.Bool, KustomerChat.KError>) -> Swift.Void))
  final public func logOut(_ completion: @escaping ((KustomerChat.KError?) -> Swift.Void))
  final public func logIn(jwt: Swift.String, _ completion: @escaping ((Swift.Result<KustomerChat.KUSTrackingIdentity, KustomerChat.KError>) -> Swift.Void))
  final public func logOutThenLogIn(jwt: Swift.String, _ completion: @escaping ((Swift.Result<KustomerChat.KUSTrackingIdentity, KustomerChat.KError>) -> Swift.Void))
  final public func openNewConversation(initialMessages: [Swift.String]? = nil, presentingVC: UIKit.UIViewController? = nil, afterCreateConversation: ((KustomerChat.KUSConversation) -> Swift.Void)? = nil, animated: Swift.Bool = true)
  final public func didFailToRegisterForRemoteNotifications(error: Swift.Error)
  final public func didRegisterForRemoteNotifications(deviceToken: Foundation.Data)
  final public func deregisterCurrentDeviceForPushNotifications(_ completion: @escaping ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void))
  final public func requestAuthorizationForPush()
  final public func stop()
  final public func start(completion: @escaping (() -> Swift.Void), failure: @escaping ((Swift.Error) -> Swift.Void))
  final public func start()
  final public func start(completion: @escaping (() -> Swift.Void))
  final public func start(failure: @escaping ((Swift.Error) -> Swift.Void))
  final public var unUserNotificationCenterDelegate: UserNotifications.UNUserNotificationCenterDelegate? {
    get
    set
  }
  final public func printLocalizationKeys()
  final public func overrideAssetLanguage(languageCode: KustomerChat.KustomerAssetLanguage)
  @objc override dynamic public init()
  final public func openChatAssistant(id: Swift.String, startDialog: Swift.String?, presentingVC: UIKit.UIViewController? = nil, completion: @escaping ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void), afterFirstMessage: @escaping ((KustomerChat.KUSConversation) -> Swift.Void) = { c in }, initialMessages: [Swift.String]? = nil, animated: Swift.Bool = true)
  @available(*, deprecated)
  final public func openNewChat(initialMessages: [Swift.String]? = nil, afterCreateConversation: ((KustomerChat.KUSConversation) -> Swift.Void)? = nil, animated: Swift.Bool = true)
  final public func getUnreadCount() -> Swift.Int
  final public func openConversationCount() -> Swift.Int
  final public func shareDebugLogs()
  @objc deinit
}
extension KustomerClient : UIKit.UIAdaptivePresentationControllerDelegate {
  @objc final public func presentationControllerDidDismiss(_ presentationController: UIKit.UIPresentationController)
}
extension Bundle {
  public static func getBundle(bundleName: Swift.String) -> Foundation.Bundle?
  public static let kustomerAssets: Foundation.Bundle?
}
public enum PushEnvironment : Swift.String {
  case development
  case production
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class Notify {
  public static func showCustom(title: Swift.String?, subtitle: Swift.String?, body: Swift.String?, delay: Swift.Double = 0.0)
  public static func showCustom(string: Swift.String, delay: Swift.Double = 0.0)
  public static func show(_ title: Swift.String, delay: Swift.Double = 0.0)
  public static func showNativeOrCustomAndRequestAuthorizationIfNeeded(title: Swift.String? = nil, subtitle: Swift.String? = nil, body: Swift.String? = nil, isRecursive: Swift.Bool = false, delay: Swift.Double = 0.0)
  public static func showNativeOrCustom(title: Swift.String? = nil, subtitle: Swift.String? = nil, body: Swift.String? = nil, requestAuthorizationIfNeeded: Swift.Bool = true, doRecursiveAuthorizationRequest: Swift.Bool = false, delay: Swift.Double = 0.0)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KUSAssistant : Swift.CustomStringConvertible {
  public var dialog: Swift.String
  public var id: Swift.String
  public var node: Swift.String
  public var initialMessagesRawJson: [Any]
  public var publicName: Swift.String?
  public var avatarUrl: Swift.String?
  public var initialMessages: [KustomerChat.KUSChatMessage] {
    get
  }
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class SupportTabViewController : UIKit.UITabBarController {
  @objc override final public func viewDidDisappear(_ animated: Swift.Bool)
  @objc override final public func viewWillDisappear(_ animated: Swift.Bool)
  @objc override final public func viewWillAppear(_ animated: Swift.Bool)
  @objc override final public func viewDidAppear(_ animated: Swift.Bool)
  @objc override final public func viewDidLoad()
  @objc override final public func viewDidLayoutSubviews()
  final public var isCurrentlyVisible: Swift.Bool {
    get
  }
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
extension SupportTabViewController : KustomerChat.KUSChatListener {
  final public func onUnreadCountChange(count: Swift.Int)
}
extension SupportTabViewController : KustomerChat.CoordinatorDelegate {
  final public func coordinatorDidHide(_ coordinator: KustomerChat.Coordinator)
}
public enum KustomerError : Swift.Error {
  case networkError(KustomerChat.NetworkError)
  case someError(Swift.String)
}
extension KustomerError : Foundation.LocalizedError {
  public var failureReason: Swift.String? {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
}
public struct KSet : Swift.Decodable {
  public var publishKey: Swift.String?
  public var subscribeKey: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public protocol KBCategoryCollectionManager : AnyObject {
  var dataSource: KustomerChat.KBCategoryCollectionDataSource? { get set }
  func reload()
}
public class KUSKBCategory : KustomerChat.KUSKBItemBase, Swift.CustomStringConvertible {
  public var id: Swift.String?
  public var htmlBody: Swift.String?
  public var title: Swift.String?
  public var metaDescription: Swift.String?
  public var rawJson: Swift.String?
  public var isRoot: Swift.Bool
  public var categoryDescription: Swift.String?
  public var lang: Swift.String?
  public var slug: Swift.String?
  public init()
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KUSChatMessage : Swift.CustomStringConvertible {
  public var id: Swift.String
  public var conversationId: Swift.String
  public var createdAt: Foundation.Date?
  public var status: KustomerChat.KUSChatMessageStatus?
  public var direction: KustomerChat.KUSChatMessageDirection?
  public var body: Swift.String?
  public var attachments: [KustomerChat.KUSChatAttachment]
  public var templateType: KustomerChat.KUSMessageTemplateType?
  public var sentById: Swift.String?
  public var sentByType: KustomerChat.KUSSentByType?
  public var actions: [KustomerChat.KUSMessageAction]?
  public var mllNode: KustomerChat.KUSMLLNode?
  public var deflectResults: [KustomerChat.KUSKBDeflectResult]?
  public var templateRawJson: Swift.String?
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ChatHistoryCoordinator : KustomerChat.CoordinatorCreator, KustomerChat.Coordinator {
  weak final public var delegate: KustomerChat.CoordinatorDelegate?
  final public var view: UIKit.UIViewController
  weak final public var navigationController: UIKit.UINavigationController?
  final public var currentCoordinator: KustomerChat.Coordinator?
  public static func make() -> KustomerChat.Coordinator
  final public func show(in navigationController: UIKit.UINavigationController?)
  @objc deinit
}
public enum KustomerUI {
}
extension KustomerUI {
  @_hasMissingDesignatedInitializers public class Color {
    @objc deinit
  }
}
extension KustomerUI.Color {
  public static var systemBackground: UIKit.UIColor {
    get
  }
  public static var secondarySystemGroupedBackground: UIKit.UIColor {
    get
  }
  public static var systemGray5: UIKit.UIColor {
    get
  }
  public static var tertiarySystemGroupedBackground: UIKit.UIColor {
    get
  }
  public static var label: UIKit.UIColor {
    get
  }
  public static var secondaryLabel: UIKit.UIColor {
    get
  }
  public static var tertiaryLabel: UIKit.UIColor {
    get
  }
  public static var systemGray3: UIKit.UIColor {
    get
  }
  public static var systemFill: UIKit.UIColor {
    get
  }
  public static func color(_ named: Swift.String) -> UIKit.UIColor?
}
public struct KnowledgeBaseDomain : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension KnowledgeBaseDomain {
  public struct Attributes : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
}
extension KnowledgeBaseDomain {
  public enum Status : Swift.Codable, Swift.RawRepresentable {
    public typealias RawValue = Swift.String
    case ready
    case some(value: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public init(rawValue: Swift.String)
  }
}
extension KustomerChat.KustomerLanguage : Swift.Equatable {}
extension KustomerChat.KustomerLanguage : Swift.Hashable {}
extension KustomerChat.KustomerLanguage : Swift.RawRepresentable {}
extension KustomerChat.KustomerAssetLanguage : Swift.Equatable {}
extension KustomerChat.KustomerAssetLanguage : Swift.Hashable {}
extension KustomerChat.KustomerAssetLanguage : Swift.RawRepresentable {}
extension KustomerChat.KUSKBDeflectResultType : Swift.Equatable {}
extension KustomerChat.KUSKBDeflectResultType : Swift.Hashable {}
extension KustomerChat.KUSKBDeflectResultType : Swift.RawRepresentable {}
extension KustomerChat.KUSSentByType : Swift.Equatable {}
extension KustomerChat.KUSSentByType : Swift.Hashable {}
extension KustomerChat.KUSSentByType : Swift.RawRepresentable {}
extension KustomerChat.KustomerConnectionStatus : Swift.Equatable {}
extension KustomerChat.KustomerConnectionStatus : Swift.Hashable {}
extension KustomerChat.KustomerConnectionStatus : Swift.RawRepresentable {}
extension KustomerChat.KUSChatMessageDirection : Swift.Equatable {}
extension KustomerChat.KUSChatMessageDirection : Swift.Hashable {}
extension KustomerChat.KUSChatMessageDirection : Swift.RawRepresentable {}
extension KustomerChat.KustomerConfigurationError : Swift.Equatable {}
extension KustomerChat.KustomerConfigurationError : Swift.Hashable {}
extension KustomerChat.KUSConversationLockReason : Swift.Equatable {}
extension KustomerChat.KUSConversationLockReason : Swift.Hashable {}
extension KustomerChat.KUSConversationLockReason : Swift.RawRepresentable {}
extension KustomerChat.KHTTPMethod : Swift.Equatable {}
extension KustomerChat.KHTTPMethod : Swift.Hashable {}
extension KustomerChat.KHTTPMethod : Swift.RawRepresentable {}
extension KustomerChat.KnowledgeBaseDocumentType : Swift.Equatable {}
extension KustomerChat.KnowledgeBaseDocumentType : Swift.Hashable {}
extension KustomerChat.KnowledgeBaseDocumentType : Swift.RawRepresentable {}
extension KustomerChat.KustomerOffhoursDisplay : Swift.Equatable {}
extension KustomerChat.KustomerOffhoursDisplay : Swift.Hashable {}
extension KustomerChat.KustomerOffhoursDisplay : Swift.RawRepresentable {}
extension KustomerChat.KnowledgeBaseCategoryViewMode : Swift.Equatable {}
extension KustomerChat.KnowledgeBaseCategoryViewMode : Swift.Hashable {}
extension KustomerChat.KUSChatMessageStatus : Swift.Equatable {}
extension KustomerChat.KUSChatMessageStatus : Swift.Hashable {}
extension KustomerChat.KUSMessageTemplateType : Swift.Equatable {}
extension KustomerChat.KUSMessageTemplateType : Swift.Hashable {}
extension KustomerChat.KUSMessageTemplateType : Swift.RawRepresentable {}
extension KustomerChat.KustomerDisplayMode : Swift.Equatable {}
extension KustomerChat.KustomerDisplayMode : Swift.Hashable {}
extension KustomerChat.KUSConversationStatus : Swift.Equatable {}
extension KustomerChat.KUSConversationStatus : Swift.Hashable {}
extension KustomerChat.KustomerLogType : Swift.Equatable {}
extension KustomerChat.KustomerLogType : Swift.Hashable {}
extension KustomerChat.KustomerLogType : Swift.RawRepresentable {}
extension KustomerChat.PushEnvironment : Swift.Equatable {}
extension KustomerChat.PushEnvironment : Swift.Hashable {}
extension KustomerChat.PushEnvironment : Swift.RawRepresentable {}
