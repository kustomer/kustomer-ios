// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name KustomerChat
import AVFoundation
import CommonCrypto
import CoreGraphics
import CoreImage
import Dispatch
import Foundation
@_exported import KustomerChat
import MobileCoreServices
import OSLog
import PubNub
import QuickLook
import SafariServices
import Swift
import SystemConfiguration
import UIKit
import UserNotifications
import WebKit
import _Concurrency
import os.log
import os
@_hasMissingDesignatedInitializers public class KUSUser : Swift.CustomStringConvertible {
  public var id: Swift.String?
  public var displayName: Swift.String?
  public var avatarUrl: Swift.String?
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ConnectionProvider {
  public static let shared: KustomerChat.ConnectionProvider
  public func reconnect()
  public var status: KustomerChat.KustomerConnectionStatus {
    get
  }
  public var listeners: [Swift.String : KustomerChat.KUSConnectionListener]
  public func addListener(_ listener: KustomerChat.KUSConnectionListener) -> Swift.String
  public func removeListener(_ uuid: Swift.String)
  public func removeAllListeners()
  @objc deinit
}
public enum KUSMessageType : Swift.Codable {
  case chatMessage
  case satisfactionResponse
  case chatSession
  case customer
  case unknown(value: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class KUSCustomer : Swift.CustomStringConvertible {
  public var id: Swift.String
  public var description: Swift.String {
    get
  }
  @objc deinit
}
public enum KustomerLanguage : Swift.String {
  case af
  case sq
  case ar
  case ar_eg
  case ar_ma
  case be
  case bs
  case bg
  case ca
  case hr
  case cs
  case da
  case nl
  case en_ca
  case en_gb
  case en_us
  case et
  case fil
  case fr
  case fr_ca
  case fr_ma
  case ka
  case de
  case el
  case he
  case hi
  case hu
  case `is`
  case id
  case it
  case ja
  case kk
  case ky
  case ko
  case lv
  case lt
  case no
  case fa
  case pl
  case br
  case pt
  case pa
  case ro
  case ru
  case sr
  case sr_me
  case zh_cn
  case sk
  case sl
  case es
  case es_ar
  case es_pa
  case es_pe
  case es_es
  case sw
  case sv
  case th
  case zh_tw
  case tr
  case tw
  case uk
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KustomerAssetLanguage : Swift.String {
  case af
  case am
  case ar
  case az
  case be
  case bg
  case bn
  case bs
  case ca
  case ceb
  case co
  case cs
  case cy
  case da
  case de
  case el
  case en
  case eo
  case es
  case et
  case eu
  case fa
  case fi
  case fr
  case fy
  case ga
  case gd
  case gl
  case gu
  case ha
  case haw
  case he
  case hi
  case hmn
  case hr
  case ht
  case hu
  case hy
  case id
  case ig
  case `is`
  case it
  case iw
  case ja
  case jw
  case ka
  case kk
  case km
  case kn
  case ko
  case ku
  case ky
  case la
  case lb
  case lo
  case lt
  case lv
  case mg
  case mi
  case mk
  case ml
  case mn
  case mr
  case ms
  case mt
  case my
  case ne
  case nl
  case no
  case ny
  case or
  case pa
  case pl
  case ps
  case pt
  case ro
  case ru
  case rw
  case sd
  case si
  case sk
  case sl
  case sm
  case sn
  case so
  case sq
  case sr
  case st
  case su
  case sv
  case sw
  case ta
  case te
  case tg
  case th
  case tk
  case tl
  case tr
  case tt
  case ug
  case uk
  case ur
  case uz
  case vi
  case xh
  case yi
  case yo
  case zh
  case zh_CN
  case zh_TW
  case zu
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class PushProvider : ObjectiveC.NSObject, UserNotifications.UNUserNotificationCenterDelegate {
  public static let shared: KustomerChat.PushProvider
  public var deviceToken: Foundation.Data? {
    get
  }
  public var deviceTokenString: Swift.String? {
    get
  }
  public func deregisterCurrentDeviceForPushNotifications(_ completion: @escaping ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void))
  public func didFailToRegisterForRemoteNotifications(error: Swift.Error)
  public func didRegisterForRemoteNotifications(deviceToken: Foundation.Data)
  public func requestAuthorizationForPush()
  public func listLivePushChannelRegistrations(completion: ((Swift.Result<[Swift.String], KustomerChat.KError>) -> Swift.Void)? = nil)
  @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, didReceive response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)
  @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, willPresent notification: UserNotifications.UNNotification, withCompletionHandler completionHandler: @escaping (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
  @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, openSettingsFor notification: UserNotifications.UNNotification?)
  public func notificationIsFromKustomer(_ notification: UserNotifications.UNNotification) -> Swift.Bool
  public func notificationIsFromKustomer(threadIdentifier: Swift.String?) -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public struct KnowledgeBaseProvider {
  public func getRootCategory(lang: Swift.String, knowledgeBaseID: Swift.String?, completion: @escaping KustomerChat.KustomerCompletion<KustomerChat.KnowledgeBaseCategory>)
  public func getCategory(by id: Swift.String, childrenLimit: Swift.Int, lang: Swift.String, knowledgeBaseID: Swift.String?, completion: @escaping KustomerChat.KustomerCompletion<KustomerChat.KnowledgeBaseResponse>)
  public func searchArticles(term: Swift.String, page: Swift.Int, pageSize: Swift.Int, lang: Swift.String, completion: @escaping KustomerChat.KustomerCompletion<[KustomerChat.KnowledgeBaseArticle]>)
  public func getArticle(by id: Swift.String, lang: Swift.String, knowledgeBaseID: Swift.String?, completion: @escaping KustomerChat.KustomerCompletion<KustomerChat.KnowledgeBaseArticle>)
}
public protocol CoordinatorDelegate : AnyObject {
  func coordinatorWillDisappear(_ coordinator: KustomerChat.Coordinator)
  func coordinatorWillAppear(_ coordinator: KustomerChat.Coordinator)
  func coordinatorDidAppear(_ coordinator: KustomerChat.Coordinator)
  func coordinatorDidDisappear(_ coordinator: KustomerChat.Coordinator)
  func coordinatorDidHide(_ coordinator: KustomerChat.Coordinator)
}
extension KustomerChat.CoordinatorDelegate {
  public func coordinatorWillDisappear(_ coordinator: KustomerChat.Coordinator)
  public func coordinatorWillAppear(_ coordinator: KustomerChat.Coordinator)
  public func coordinatorDidAppear(_ coordinator: KustomerChat.Coordinator)
  public func coordinatorDidDisappear(_ coordinator: KustomerChat.Coordinator)
  public func coordinatorDidHide(_ coordinator: KustomerChat.Coordinator)
}
public struct KUSAlertSettings {
}
public typealias KUSAlertCompletionHandler = ((KustomerChat.KUSAlertResult) -> Swift.Void)
public enum KUSAlertButtonType {
  case cancel(title: Swift.String)
  case other(title: Swift.String)
  case preferred(title: Swift.String)
  case destructive(title: Swift.String)
  case textField(text: Swift.String, placeholder: Swift.String?)
}
public enum KUSAlertResult {
  case cancel
  case other(inputText: [Swift.String])
}
@_hasMissingDesignatedInitializers public class KUSAlertManager {
  @objc deinit
}
public struct KUSAlertInfo {
}
@objc @_Concurrency.MainActor(unsafe) public class KUSSWAlert : ObjectiveC.NSObject, UIKit.UIAlertViewDelegate {
  @_Concurrency.MainActor(unsafe) public static var lastTextEntered: [Swift.String?]
  @_Concurrency.MainActor(unsafe) public static func showAlert(_ title: Swift.String?, message: Swift.String?, buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil)
  @_Concurrency.MainActor(unsafe) public init(title: Swift.String?, message: Swift.String?)
  @_Concurrency.MainActor(unsafe) public func setCancelAction(_ buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func setCancelAction(_ buttonTitle: Swift.String) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func addAction(_ buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func addDestructiveAction(_ buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func addDefaultAction(_ buttonTitle: Swift.String, _ completion: KustomerChat.KUSAlertCompletionHandler? = nil) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func addAction(_ buttonTitle: Swift.String) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func addTextField(_ text: Swift.String, placeholder: Swift.String? = nil) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func addTextField(_ text: Swift.String) -> KustomerChat.KUSSWAlert
  @_Concurrency.MainActor(unsafe) public func show()
  @_Concurrency.MainActor(unsafe) public func showActionSheet()
  @objc deinit
}
public struct KnowledgeBaseArticle : Swift.Decodable {
  public let id: Swift.String
  public let type: Swift.String
  public let attributes: KustomerChat.KnowledgeBaseArticleAttributes
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseArticleAttributes : Swift.Decodable {
  public var articleId: Swift.String {
    get
  }
  public let title: Swift.String
  public let htmlBody: Swift.String?
  public let lang: Swift.String
  public var published: Swift.Bool
  public let updatedAt: Foundation.Date?
  public let publishedAt: Foundation.Date?
  public let version: Swift.Int
  public let knowledgeBaseID: Swift.String?
  public let slug: Swift.String
  public let hash: Swift.String
  public var kbURL: Swift.String {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct BusinessHours : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum Weekday : Swift.String, Swift.Codable {
  case sunday
  case monday
  case tuesday
  case wednesday
  case thursday
  case friday
  case saturday
  case none
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct KUSKBDeflectResult : Swift.Decodable {
  public var id: Swift.String?
  public var articleId: Swift.String?
  public var type: KustomerChat.KUSKBDeflectResultType?
  public var knowledgeBaseId: Swift.String?
  public var title: Swift.String?
  public var webLink: Swift.String?
  public var lang: Swift.String?
  public init(id: Swift.String?, articleId: Swift.String?, type: KustomerChat.KUSKBDeflectResultType?, title: Swift.String?, webLink: Swift.String?, lang: Swift.String?, rawJson: Swift.String?, clickCount: Swift.Int = 0)
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class KUSChatAttachment : Swift.CustomStringConvertible {
  final public var id: Swift.String
  final public var conversationId: Swift.String?
  final public var contentType: Swift.String?
  final public var url: Swift.String?
  final public var name: Swift.String?
  final public var chatMessageId: Swift.String?
  final public var description: Swift.String {
    get
  }
  @objc deinit
}
public struct KUSCSATForm : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct KUSCSATScale : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum KUSCSATScaleType : Swift.Codable {
  case number
  case emoji
  case thumb
  case unknown
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: KustomerChat.KUSCSATScaleType, b: KustomerChat.KUSCSATScaleType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct KUSCSATQuestion : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum KUSCSATQuestionType : Swift.String, Swift.Codable {
  case text
  case radio
  case checkbox
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class KnowledgeBaseCategoryLoader {
  @objc deinit
}
public class KUSTrackingIdentity : Swift.Decodable {
  public var id: Swift.String?
  public var customerId: Swift.String?
  public var trackingId: Swift.String?
  public var trackingToken: Swift.String?
  public var email: Swift.String?
  public var externalId: Swift.String?
  public var verified: Swift.Bool?
  public var verifiedAt: Foundation.Date?
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date?
  required public init(from decoder: Swift.Decoder)
  @objc deinit
}
public protocol KBCategoryCollectionDataSource : AnyObject {
  var sectionTitle: Swift.String? { get }
  var rows: [KustomerChat.KnowledgeBaseDataRow] { get }
  var showFooter: Swift.Bool { get }
}
@_hasMissingDesignatedInitializers public class Settings {
  public var teamName: Swift.String {
    get
    set
  }
  public var teamIconUrl: Swift.String {
    get
    set
  }
  public var widgetType: Swift.String? {
    get
    set
  }
  public var greeting: Swift.String {
    get
    set
  }
  public var offhoursDisplay: KustomerChat.KustomerOffhoursDisplay {
    get
    set
  }
  public var offhoursMessage: Swift.String {
    get
    set
  }
  public var offhoursImageUrl: Swift.String? {
    get
    set
  }
  public var waitMessage: Swift.String? {
    get
    set
  }
  public var activeAssistant: Swift.String? {
    get
    set
  }
  public var enabled: Swift.Bool? {
    get
    set
  }
  public var didLoadSettingsFirstTime: Swift.Bool {
    get
    set
  }
  public var singleSessionChat: Swift.Bool {
    get
    set
  }
  public var closableChat: Swift.Bool {
    get
    set
  }
  public var noHistory: Swift.Bool {
    get
    set
  }
  public var showTypingIndicatorWeb: Swift.Bool {
    get
    set
  }
  public var showTypingIndicatorCustomerWeb: Swift.Bool {
    get
    set
  }
  public var autoreply: Swift.String {
    get
    set
  }
  public var embedIconUrl: Swift.String {
    get
    set
  }
  public var embedIconColor: Swift.String? {
    get
    set
  }
  public var activeForm: Swift.String? {
    get
    set
  }
  public var campaignsEnabled: Swift.Bool {
    get
    set
  }
  public var pusherAccessKey: Swift.String {
    get
    set
  }
  public var pusherCluster: Swift.String {
    get
    set
  }
  public var volumeControlTimeout: Swift.Int {
    get
    set
  }
  public var volumeControlPromptDelay: Swift.Int {
    get
    set
  }
  public var volumeControlUpfrontWaitThreshold: Swift.Int {
    get
    set
  }
  public var csatLockTime: Swift.Int? {
    get
    set
  }
  public var csatDebounceSendTime: Swift.Int {
    get
    set
  }
  public var volumeControlMode: Swift.String {
    get
    set
  }
  public var volumeControlCustomWaitMessage: Swift.String? {
    get
    set
  }
  public var volumeControlEnabled: Swift.Bool {
    get
    set
  }
  public var volumeControlMarkDoneAfterTimeout: Swift.Bool {
    get
    set
  }
  public var volumeControlUseDynamicWaitMessage: Swift.Bool {
    get
    set
  }
  public var volumeControlHideWaitOption: Swift.Bool {
    get
    set
  }
  public var showEmailInputBanner: Swift.Bool {
    get
    set
  }
  public var csatInboundMessagesOverride: Swift.Bool {
    get
    set
  }
  public var csatOutboundMessagesOverride: Swift.Bool {
    get
    set
  }
  public var volumeControlFollowUpChannels: [Swift.String] {
    get
    set
  }
  public var shouldDisableAttachments: Swift.Bool {
    get
    set
  }
  @objc deinit
}
public protocol KUSURLConvertible {
  func kus_asURL() throws -> Foundation.URL
}
extension Swift.String : KustomerChat.KUSURLConvertible {
  public func kus_asURL() throws -> Foundation.URL
}
extension Foundation.URL : KustomerChat.KUSURLConvertible {
  public func kus_asURL() throws -> Foundation.URL
}
extension Foundation.URLComponents : KustomerChat.KUSURLConvertible {
  public func kus_asURL() throws -> Foundation.URL
}
public typealias KustomerCompletion<T> = (Swift.Result<T, KustomerChat.KustomerError>) -> Swift.Void
public enum KustomerClientStatus {
  case uninitialized
  case configured
  case configurationError(error: KustomerChat.KError?)
  case starting
  case started
  case stopped
  case connected
  case disconnected
}
public protocol KUSConnectionListener {
  func onPubNubConnectionStatusChange(status: KustomerChat.KustomerConnectionStatus)
}
extension KustomerChat.KUSConnectionListener {
  public func onPubNubConnectionStatusChange(status: KustomerChat.KustomerConnectionStatus)
}
public let Kustomer: KustomerChat.KustomerClient
public typealias KUSPNTtoken = Swift.UInt64
public enum KUSKBDeflectResultType : Swift.String, Swift.Decodable {
  case article
  case category
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol CoordinatorCreator : AnyObject {
  var currentCoordinator: KustomerChat.Coordinator? { get set }
  static func make() -> KustomerChat.Coordinator
}
public struct KnowledgeBase : Swift.Decodable {
  public let id: Swift.String
  public let type: Swift.String
  public let attributes: KustomerChat.KnowledgeBaseAttributes
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseAttributes : Swift.Decodable {
  public let name: Swift.String
  public let subdomain: Swift.String
  public let articleSurvey: KustomerChat.KnowledgeBaseSurvey
  public init(from decoder: Swift.Decoder) throws
}
final public class KUSKBArticle : KustomerChat.KUSKBItemBase, Swift.CustomStringConvertible {
  final public var id: Swift.String?
  final public var htmlBody: Swift.String?
  final public var title: Swift.String?
  final public var metaDescription: Swift.String?
  final public var rawJson: Swift.String?
  final public var hashIdentifier: Swift.String?
  final public var versionId: Swift.String?
  final public var slug: Swift.String?
  final public var lang: Swift.String?
  public init()
  final public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ChatProvider {
  public static let shared: KustomerChat.ChatProvider
  public var listeners: [Swift.String : KustomerChat.KUSChatListener] {
    get
  }
  public func addChatListener(_ listener: KustomerChat.KUSChatListener) -> Swift.String
  public func removeChatListener(_ uuid: Swift.String)
  public func removeAllChatListeners()
  public func listenForTyping(conversationId: Swift.String)
  public func stopListeningForTyping(conversationId: Swift.String)
  public func sendTypingStatus(for conversationId: Swift.String, isTyping: Swift.Bool)
  public func getConversations(completion: @escaping (Swift.Result<[KustomerChat.KUSConversation], KustomerChat.KError>) -> Swift.Void)
  public func getConversationPage(page: Swift.Int, pageSize: Swift.Int, completion: @escaping (Swift.Result<[KustomerChat.KUSConversation], KustomerChat.KError>) -> Swift.Void)
  public func getConversation(conversationId: Swift.String, completion: @escaping (Swift.Result<KustomerChat.KUSConversation, KustomerChat.KError>) -> Swift.Void)
  public func getChatMessages(conversationId: Swift.String, completion: @escaping (Swift.Result<[KustomerChat.KUSChatMessage], KustomerChat.KError>) -> Swift.Void)
  public func getChatMessagesBefore(timestamp: Foundation.Date, conversationId: Swift.String, count: Swift.Int, completion: @escaping (Swift.Result<[KustomerChat.KUSChatMessage], KustomerChat.KError>) -> Swift.Void)
  public func getHistoricChatMessages(conversationId: Swift.String, completion: @escaping (Swift.Result<[KustomerChat.KUSChatMessage], KustomerChat.KError>) -> Swift.Void)
  public func getInitialMessages(assistantId: Swift.String? = nil, startDialog: Swift.String? = nil, completion: @escaping (Swift.Result<[KustomerChat.KUSChatMessage], KustomerChat.KError>) -> Swift.Void)
  public func reloadChatSettings(_ callback: @escaping ((KustomerChat.KError?) -> Swift.Void))
  public func getUnreadCount(completion: @escaping (Swift.Result<Swift.Int, KustomerChat.KError>) -> Swift.Void)
  public func getOpenConversationCount(completion: @escaping (Swift.Result<Swift.Int, KustomerChat.KError>) -> Swift.Void)
  public func getActiveConversations(completion: @escaping (Swift.Result<[KustomerChat.KUSConversation], KustomerChat.KError>) -> Swift.Void)
  public func customerExists() -> Swift.Bool
  public func getChatSettings() -> KustomerChat.KUSChatSettings
  public func isChatAvailable() -> Swift.Bool?
  public func createConversation(firstCustomerMessage text: Swift.String? = nil, title: Swift.String? = nil, customDescribe: KustomerChat.KUSCustomDescribe? = nil, action: KustomerChat.KUSMessageAction? = nil, mllNode: KustomerChat.KUSMLLNode? = nil, image: UIKit.UIImage? = nil, fileURL: Foundation.URL? = nil, overrideAssistantId: Swift.String? = nil, completion: @escaping ((Swift.Result<(conversation: KustomerChat.KUSConversation, messages: [KustomerChat.KUSChatMessage], customer: KustomerChat.KUSCustomer?), KustomerChat.KError>) -> Swift.Void))
  public func sendChatMessage(text: Swift.String, conversationId: Swift.String, completion: @escaping ((Swift.Result<(message: KustomerChat.KUSChatMessage, conversation: KustomerChat.KUSConversation), KustomerChat.KError>) -> Swift.Void))
  public func sendChatMessage(action: KustomerChat.KUSMessageAction, conversationId: Swift.String, additionalParams: [Swift.String : Any]? = nil, completion _outerCompletion: @escaping (Swift.Result<(message: KustomerChat.KUSChatMessage, conversation: KustomerChat.KUSConversation), KustomerChat.KError>) -> Swift.Void)
  public func sendChatMessage(text: Swift.String, assistant: KustomerChat.KUSAssistant, conversationId: Swift.String, completion _outerCompletion: @escaping (Swift.Result<(message: KustomerChat.KUSChatMessage, conversation: KustomerChat.KUSConversation), KustomerChat.KError>) -> Swift.Void)
  public func sendChatMessage(mllNode: KustomerChat.KUSMLLNode, conversationId: Swift.String, additionalParams: [Swift.String : Any]? = nil, completion _outerCompletion: @escaping (Swift.Result<(message: KustomerChat.KUSChatMessage, conversation: KustomerChat.KUSConversation), KustomerChat.KError>) -> Swift.Void)
  public func sendChatMessage(image: UIKit.UIImage, conversationId: Swift.String, completion: @escaping ((KustomerChat.KError?) -> Swift.Void))
  public func sendChatMessage(fileUrl: Foundation.URL, conversationId: Swift.String, completion: @escaping ((KustomerChat.KError?) -> Swift.Void))
  @available(*, deprecated, message: "No longer supported. Use `getInitialMessages` to fetch initial assistant messages to display, then call `createConversation` to send the first customer message.")
  public func createAssistant(id: Swift.String, startDialog: Swift.String?, after: @escaping ((KustomerChat.KUSAssistant) -> Swift.Void), error: @escaping ((KustomerChat.KError) -> Swift.Void), afterCreateConversation: ((KustomerChat.KUSConversation) -> Swift.Void)? = { _ in }) -> Swift.String
  public func endConversation(conversationId: Swift.String, completion: @escaping ((Swift.Result<KustomerChat.KUSConversation, KustomerChat.KError>) -> Swift.Void))
  public func describeConversation(conversationId: Swift.String, attributes: [Swift.String : Any], _ completion: @escaping ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void))
  public func describeCurrentCustomer(phone: Swift.String? = nil, email: Swift.String? = nil, phones: [Swift.String]? = nil, emails: [Swift.String]? = nil, facebook: Swift.String? = nil, instagram: Swift.String? = nil, twitter: Swift.String? = nil, linkedIn: Swift.String? = nil, custom: [Swift.String : Any]? = nil, _ completion: ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void)? = nil)
  public func markRead(conversationId: Swift.String)
  public func markRead(conversationId: Swift.String, messageIds: [Swift.String])
  public func sendPresenceActivity(_ presence: KustomerChat.PresenceType)
  public func submitSatisfactionForm(conversationSatisfactionId: Swift.String, response: KustomerChat.KUSCSATNetworkPostBody, conversationId: Swift.String, completion: @escaping ((Swift.Result<KustomerChat.KUSSatisfaction, KustomerChat.KError>) -> Swift.Void))
  @objc deinit
}
public enum KUSSentByType : Swift.String {
  case User
  case Customer
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class KBArticleCoordinator : KustomerChat.DataCoordinatorCreator, KustomerChat.Coordinator {
  weak final public var delegate: KustomerChat.CoordinatorDelegate?
  public typealias KnowledgeBaseArticleData = (article: KustomerChat.KnowledgeBaseArticle?, id: Swift.String)
  public typealias Value = KustomerChat.KBArticleCoordinator.KnowledgeBaseArticleData
  final public var view: UIKit.UIViewController {
    get
  }
  final public var navigationController: UIKit.UINavigationController?
  final public var currentCoordinator: KustomerChat.Coordinator?
  public static func make(value: KustomerChat.KBArticleCoordinator.KnowledgeBaseArticleData) -> KustomerChat.Coordinator
  final public func show(in navigationController: UIKit.UINavigationController?)
  @objc deinit
}
public class KustomerOptions {
  public init()
  public var enableUI: Swift.Bool
  public var showInAppNotifications: Swift.Bool
  public var language: KustomerChat.KustomerLanguage?
  public var debugMode: Swift.Bool
  @available(*, deprecated, message: "Pass a reference to the presenting view controller in the appropiate Kustomer API")
  public var hostViewController: UIKit.UIViewController?
  public var activeAssistant: KustomerChat.ActiveAssistantOptions
  public var disablePush: Swift.Bool
  public var pushBundleId: Swift.String {
    get
    set
  }
  public var pushEnvironment: KustomerChat.PushEnvironment
  public var hideNewConversationButtonInClosedChat: Swift.Bool
  public var showAnimationFor5StarCSATRatings: Swift.Bool
  public var onShow: (() -> Swift.Void)?
  public var onDismiss: (() -> Swift.Void)?
  @available(*, deprecated, message: "Use onShow instead")
  public var onViewDidAppear: ((Swift.Bool) -> Swift.Void)?
  @available(*, deprecated, message: "Use onShow instead")
  public var onViewWillAppear: ((Swift.Bool) -> Swift.Void)?
  @available(*, deprecated, message: "Use onDismiss instead")
  public var onViewWillDisappear: ((Swift.Bool) -> Swift.Void)?
  @available(*, deprecated, message: "Use onDismiss instead")
  public var onViewDidDisappear: ((Swift.Bool) -> Swift.Void)?
  public var hostDomain: Swift.String?
  public var businessScheduleId: Swift.String?
  @available(*, deprecated, message: "Use `brandId` instead whenever possible. This will override the brand id's knowledge base id.")
  public var knowledgeBaseID: Swift.String?
  public var brandId: Swift.String? {
    get
    set
  }
  public var logLevels: [KustomerChat.KustomerLogType]
  public var hideNewConversationButton: Swift.Bool
  public var hideKbArticleShare: Swift.Bool
  public var flags: Swift.String?
  @KustomerChat.KUSClamping public var messageAttachmentLocalCacheMaximumSizeInBytes: Swift.Int {
    get
    set
    _modify
  }
  public var hideHistoryNavigation: Swift.Bool
  @available(*, deprecated)
  public var orgSecret: Swift.String?
  @objc deinit
}
public enum ActiveAssistantOptions {
  case none
  case orgDefault
  case withId(Swift.String)
}
public struct PreviewDetails : Swift.Codable {
  public let lastResponder: KustomerChat.LastResponder?
  public let messageCreatedAt: Foundation.Date?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct LastResponder : Swift.Codable {
  public let type: Swift.String?
  public let displayName: Swift.String?
  public let avatarUrl: Swift.String?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol CharacterStyling {
  func isEqualTo(_ other: KustomerChat.CharacterStyling) -> Swift.Bool
}
public enum TokenType {
  case repeatingTag
  case openTag
  case intermediateTag
  case closeTag
  case string
  case escape
  case replacement
  public static func == (a: KustomerChat.TokenType, b: KustomerChat.TokenType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Token {
  public let id: Swift.String
  public let type: KustomerChat.TokenType
  public let inputString: Swift.String
  public var metadataStrings: [Swift.String]
  public var group: Swift.Int {
    get
  }
  public var characterStyles: [KustomerChat.CharacterStyling] {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var shouldSkip: Swift.Bool {
    get
  }
  public var tokenIndex: Swift.Int {
    get
  }
  public var isProcessed: Swift.Bool {
    get
  }
  public var isMetadata: Swift.Bool {
    get
  }
  public var children: [KustomerChat.Token]
  public var outputString: Swift.String {
    get
  }
  public init(type: KustomerChat.TokenType, inputString: Swift.String, characterStyles: [KustomerChat.CharacterStyling] = [])
}
public protocol DataCoordinatorCreator {
  associatedtype Value
  static func make(value: Self.Value) -> KustomerChat.Coordinator
}
public protocol KUSKBItemBase : Swift.CustomStringConvertible {
  var id: Swift.String? { get set }
  var htmlBody: Swift.String? { get set }
  var title: Swift.String? { get set }
  var metaDescription: Swift.String? { get set }
  var rawJson: Swift.String? { get set }
  var description: Swift.String { get }
}
extension KustomerChat.KUSKBItemBase {
  public func completeObject() -> [Swift.String : Any]?
}
@_hasMissingDesignatedInitializers public class KBCategoryBridge : KustomerChat.KUSKBItemBase {
  public var id: Swift.String?
  public var htmlBody: Swift.String?
  public var title: Swift.String?
  public var metaDescription: Swift.String?
  public var rawJson: Swift.String?
  public var isRoot: Swift.Bool
  public var slug: Swift.String?
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KBArticleBridge : KustomerChat.KUSKBItemBase {
  public var id: Swift.String?
  public var htmlBody: Swift.String?
  public var title: Swift.String?
  public var metaDescription: Swift.String?
  public var rawJson: Swift.String?
  public var hashIdentifier: Swift.String?
  public var slug: Swift.String?
  public var lang: Swift.String?
  public var description: Swift.String {
    get
  }
  @objc deinit
}
public enum SpaceAllowed {
  case no
  case bothSides
  case oneSide
  case leadingSide
  case trailingSide
  public static func == (a: KustomerChat.SpaceAllowed, b: KustomerChat.SpaceAllowed) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum Cancel {
  case none
  case allRemaining
  case currentSet
  public static func == (a: KustomerChat.Cancel, b: KustomerChat.Cancel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum CharacterRuleTagType {
  case open
  case close
  case metadataOpen
  case metadataClose
  case repeating
  public static func == (a: KustomerChat.CharacterRuleTagType, b: KustomerChat.CharacterRuleTagType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CharacterRuleTag {
  public init(tag: Swift.String, type: KustomerChat.CharacterRuleTagType)
}
public struct CharacterRule : Swift.CustomStringConvertible {
  public let primaryTag: KustomerChat.CharacterRuleTag
  public let tags: [KustomerChat.CharacterRuleTag]
  public let escapeCharacters: [Swift.Character]
  public let styles: [Swift.Int : KustomerChat.CharacterStyling]
  public let minTags: Swift.Int
  public let maxTags: Swift.Int
  public var metadataLookup: Swift.Bool
  public var isRepeatingTag: Swift.Bool {
    get
  }
  public var definesBoundary: Swift.Bool
  public var shouldCancelRemainingRules: Swift.Bool
  public var balancedTags: Swift.Bool
  public var description: Swift.String {
    get
  }
  public func tag(for type: KustomerChat.CharacterRuleTagType) -> KustomerChat.CharacterRuleTag?
  public init(primaryTag: KustomerChat.CharacterRuleTag, otherTags: [KustomerChat.CharacterRuleTag], escapeCharacters: [Swift.Character] = ["\\"], styles: [Swift.Int : KustomerChat.CharacterStyling] = [:], minTags: Swift.Int = 1, maxTags: Swift.Int = 1, metadataLookup: Swift.Bool = false, definesBoundary: Swift.Bool = false, shouldCancelRemainingRules: Swift.Bool = false, balancedTags: Swift.Bool = false)
}
public struct KnowledgeBaseSurvey : Swift.Decodable {
  public let suggestedReasons: [KustomerChat.KnowledgeBaseSurveySuggestedReason]
  public let enabled: Swift.Bool
  public let suggestedReasonsEnabled: Swift.Bool
  public let writtenFeedbackEnabled: Swift.Bool
  public let ratingTitle: Swift.String
  public let ratingValues: [KustomerChat.KnowledgeBaseSurveyRatingValue]
  public let suggestedReasonsTitle: Swift.String
  public let writtenFeedbackTitle: Swift.String
  public let submitButtonText: Swift.String
  public let positiveConfirmationMessage: Swift.String
  public let negativeConfirmationMessage: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseSurveySuggestedReason : Swift.Decodable {
  public let displayText: Swift.String
  public let value: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseSurveyRatingValue : Swift.Decodable {
  public let value: Swift.String
  public let text: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
@propertyWrapper public struct KUSClamping<Value> : Swift.Comparable where Value : Swift.Comparable {
  public static func < (lhs: KustomerChat.KUSClamping<Value>, rhs: KustomerChat.KUSClamping<Value>) -> Swift.Bool
  public var value: Value
  public let range: Swift.ClosedRange<Value>
  public init(wrappedValue value: Value, _ range: Swift.ClosedRange<Value>)
  public var wrappedValue: Value {
    get
    set
  }
  public static func == (a: KustomerChat.KUSClamping<Value>, b: KustomerChat.KUSClamping<Value>) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class KBCategoryCoordinator : KustomerChat.DataCoordinatorCreator, KustomerChat.Coordinator {
  public typealias Value = KustomerChat.KnowledgeBaseCategoryData
  weak final public var delegate: KustomerChat.CoordinatorDelegate?
  final public var view: UIKit.UIViewController {
    get
  }
  weak final public var navigationController: UIKit.UINavigationController?
  final public var currentCoordinator: KustomerChat.Coordinator?
  public static func make(value: KustomerChat.KnowledgeBaseCategoryData) -> KustomerChat.Coordinator
  public static func make() -> KustomerChat.Coordinator
  final public func show(in navigationController: UIKit.UINavigationController?)
  @objc deinit
}
public enum KnowledgeBaseDataRow {
  case category(category: KustomerChat.KnowledgeBaseCategory, didSelect: ((_ row: KustomerChat.KnowledgeBaseCategory) -> Swift.Void)?)
  case article(article: KustomerChat.KnowledgeBaseArticle, didSelect: ((_ row: KustomerChat.KnowledgeBaseArticle) -> Swift.Void)?)
}
@objc @_Concurrency.MainActor(unsafe) final public class ConfettiView : UIKit.UIView {
  @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) final public func emit(with contents: [KustomerChat.ConfettiView.Content], for duration: Foundation.TimeInterval = 3.0)
  @_Concurrency.MainActor(unsafe) @objc override final public func willMove(toSuperview newSuperview: UIKit.UIView?)
  public enum Content {
    public enum Shape {
      case circle
      case triangle
      case square
      case custom(CoreGraphics.CGPath)
    }
    case shape(KustomerChat.ConfettiView.Content.Shape, UIKit.UIColor)
    case image(UIKit.UIImage, UIKit.UIColor?)
    case text(Swift.String)
  }
  @objc deinit
}
extension KustomerChat.ConfettiView : QuartzCore.CAAnimationDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func animationDidStop(_ animation: QuartzCore.CAAnimation, finished flag: Swift.Bool)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class NextGrowingTextView : UIKit.UIScrollView {
  @_hasMissingDesignatedInitializers open class Delegates {
    open var willChangeHeight: (CoreGraphics.CGFloat) -> Swift.Void
    open var didChangeHeight: (CoreGraphics.CGFloat) -> Swift.Void
    @objc deinit
  }
  @_Concurrency.MainActor(unsafe) open var delegates: KustomerChat.NextGrowingTextView.Delegates
  @_Concurrency.MainActor(unsafe) open var textView: UIKit.UITextView {
    get
  }
  @_Concurrency.MainActor(unsafe) open var minNumberOfLines: Swift.Int {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var maxNumberOfLines: Swift.Int {
    get
    set
  }
  @available(*, deprecated, message: "Use isAutomaticScrollToBottomEnabled")
  @_Concurrency.MainActor(unsafe) open var disableAutomaticScrollToBottom: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) open var isAutomaticScrollToBottomEnabled: Swift.Bool
  @_Concurrency.MainActor(unsafe) open var placeholderAttributedText: Foundation.NSAttributedString? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var inputView: UIKit.UIView? {
    @_Concurrency.MainActor(unsafe) @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isFirstResponder: Swift.Bool {
    @_Concurrency.MainActor(unsafe) @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreGraphics.CGSize {
    @_Concurrency.MainActor(unsafe) @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func reloadInputViews()
  @objc deinit
}
public enum KustomerConnectionStatus : Swift.String {
  case connecting
  case connected
  case reconnecting
  case disconnected
  case disconnectedUnexpectedly
  public var isActive: Swift.Bool {
    get
  }
  public var isConnected: Swift.Bool {
    get
  }
  public var ableToTryReconnecting: Swift.Bool {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol KUSChatListener : AnyObject {
  func onChatMessageReceived(conversationId: Swift.String, chatMessage: KustomerChat.KUSChatMessage)
  func onConversationEnded(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  func onConversationReOpened(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  func onOpenConversationCountChange(count: Swift.Int)
  func onConversationDeleted(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  func onConversationCreated(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  func onUnreadCountChange(count: Swift.Int)
  func onUnreadCountChange(conversationId: Swift.String, count: Swift.Int)
  func onUserJoined(conversationId: Swift.String, user: KustomerChat.KUSUser)
  func onUserIsTyping(conversationId: Swift.String, user: KustomerChat.KUSUser, timetoken: KustomerChat.KUSPNTtoken?)
  func onUserStopsTyping(conversationId: Swift.String, user: KustomerChat.KUSUser, timetoken: KustomerChat.KUSPNTtoken?)
  func onPreviewChanged(conversationId: Swift.String, preview: Swift.String, previewDetails: KustomerChat.PreviewDetails?)
  func onAssistantEnded(conversation: KustomerChat.KUSConversation)
  func onConversationMerged(sourceConversation: KustomerChat.KUSConversation, targetConversation: KustomerChat.KUSConversation)
  func onSatisfactionEventReceived(conversationId: Swift.String, satisfaction: KustomerChat.KUSSatisfaction)
  func onCustomerDeleted()
}
extension KustomerChat.KUSChatListener {
  public func onChatMessageReceived(conversationId: Swift.String, chatMessage: KustomerChat.KUSChatMessage)
  public func onConversationEnded(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  public func onConversationReOpened(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  public func onOpenConversationCountChange(count: Swift.Int)
  public func onConversationCreated(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  public func onUnreadCountChange(count: Swift.Int)
  public func onUnreadCountChange(conversationId: Swift.String, count: Swift.Int)
  public func onUserJoined(conversationId: Swift.String, user: KustomerChat.KUSUser)
  public func onUserIsTyping(conversationId: Swift.String, user: KustomerChat.KUSUser, timetoken: KustomerChat.KUSPNTtoken?)
  public func onUserStopsTyping(conversationId: Swift.String, user: KustomerChat.KUSUser, timetoken: KustomerChat.KUSPNTtoken?)
  public func onPreviewChanged(conversationId: Swift.String, preview: Swift.String, previewDetails: KustomerChat.PreviewDetails?)
  public func onAssistantEnded(conversation: KustomerChat.KUSConversation)
  public func onConversationMerged(sourceConversation: KustomerChat.KUSConversation, targetConversation: KustomerChat.KUSConversation)
  public func onSatisfactionEventReceived(conversationId: Swift.String, satisfaction: KustomerChat.KUSSatisfaction)
  public func onConversationDeleted(conversationId: Swift.String, conversation: KustomerChat.KUSConversation)
  public func onCustomerDeleted()
}
public struct KnowledgeBaseCategoryData {
}
public protocol KUSMessageAction {
  var displayText: Swift.String { get }
  var value: Swift.String { get }
}
public struct KUSButtonMessageAction : KustomerChat.KUSMessageAction, Swift.Decodable {
  public var displayText: Swift.String
  public var value: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
public struct KUSObjectMessageAction : KustomerChat.KUSMessageAction, Swift.Decodable {
  public var displayText: Swift.String {
    get
  }
  public var value: Swift.String
  public var titleText: Swift.String?
  public var detailsText: Swift.String?
  public var imageUrl: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class KUSMLLNode : Swift.Decodable {
  public var displayText: Swift.String?
  public var value: Swift.String?
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
}
public struct KUSCSATResponse : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum KUSCSATStatus : Swift.String, Swift.Codable {
  case offered
  case rated
  case commented
  case scheduled
  case unresponded
  case canceled
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct KUSCSATAnswer : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct KUSCSATNetworkPostBody : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(*, unavailable, renamed: "Notification.Name.KUS_reachabilityChanged")
public let KUSReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let KUSReachabilityChanged: Foundation.Notification.Name
}
public struct KUSConversation : Swift.CustomStringConvertible, Swift.Codable {
  public var id: Swift.String?
  public var createdAt: Foundation.Date?
  public var lastMessageAt: Foundation.Date?
  public var status: KustomerChat.KUSConversationStatus?
  public var brandId: Swift.String?
  public var lockedAt: Foundation.Date?
  public var lockedByCustomer: Swift.Bool?
  public var lockReason: KustomerChat.KUSConversationLockReason?
  public var preview: Swift.String?
  public var previewDetails: KustomerChat.PreviewDetails?
  public var respondingUserIds: [Swift.String?]?
  public var unreadMessageCount: Swift.Int?
  public var lastReadMessageId: Swift.String?
  public var isDeleted: Swift.Bool
  public var users: [KustomerChat.KUSUser] {
    mutating get
    set
  }
  public var localUuid: Swift.String?
  public var description: Swift.String {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers final public class KBProvider {
  public static let shared: KustomerChat.KBProvider
  @available(*, deprecated, message: "Please use KustomerClient.shared.kbProvider.getRootCategory")
  final public func getEntriesForRoot(completion: @escaping ((Swift.Result<[KustomerChat.KUSKBItemBase], KustomerChat.KError>) -> Swift.Void))
  @available(*, deprecated, message: "Please use KustomerClient.shared.kbProvider.searchArticles")
  final public func getEntries(parentCategoryId: Swift.String?, search: Swift.String? = nil, completion: @escaping ((Swift.Result<[KustomerChat.KUSKBItemBase], KustomerChat.KError>) -> Swift.Void))
  @available(*, deprecated, message: "Please use KustomerClient.shared.kbProvider.getCategory")
  final public func getCategory(id: Swift.String, completion: @escaping ((Swift.Result<KustomerChat.KUSKBCategory, KustomerChat.KError>) -> Swift.Void))
  @available(*, deprecated, message: "Please use KustomerClient.shared.kbProvider.getArticle")
  final public func getArticle(id: Swift.String, completion: @escaping ((Swift.Result<KustomerChat.KUSKBArticle, KustomerChat.KError>) -> Swift.Void))
  @objc deinit
}
public enum KUSChatMessageDirection : Swift.String, Swift.Decodable {
  case inbound
  case outbound
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KUSChatMessageDirectionType : Swift.String, Swift.Decodable {
  case initialIn
  case initialOut
  case followupOut
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class EventBroadcaster {
  @objc deinit
}
extension KustomerChat.KustomerUI.Color {
  public static var activeLinkColor: UIKit.UIColor
  public static var chatAvatarBackground: UIKit.UIColor
  public static var chatAvatarInitials: UIKit.UIColor
  public static var chatHeaderBackground: UIKit.UIColor
  public static var chatHeaderBackgroundWhenInAssistant: UIKit.UIColor
  public static var chatInputBarBackground: UIKit.UIColor
  public static var chatSearchBarBackground: UIKit.UIColor
  public static var chatTableBackground: UIKit.UIColor
  public static var chatTextInputBackground: UIKit.UIColor
  public static var chatNewConversationButton: UIKit.UIColor
  public static var chatNewConversationButtonText: UIKit.UIColor
  public static var chatEndedRowText: UIKit.UIColor
  public static var chatEndedRowLine: UIKit.UIColor
  public static var csatText: UIKit.UIColor
  public static var csatCommentBoxBackground: UIKit.UIColor
  public static var csatCommentBoxOutline: UIKit.UIColor
  public static var historyBackground: UIKit.UIColor
  public static var historyBadgeBackground: UIKit.UIColor
  public static var historyBadgeText: UIKit.UIColor
  public static var historyEmptyStateBackground: UIKit.UIColor
  public static var historyHeaderBackground: UIKit.UIColor
  public static var historyNewChatButton: UIKit.UIColor
  public static var historyNewChatButtonText: UIKit.UIColor
  public static var historyRowBackground: UIKit.UIColor
  public static var historyTitleColor: UIKit.UIColor
  public static var incomingMessageBubble: UIKit.UIColor
  public static var incomingMessageText: UIKit.UIColor
  public static var loadingNavigationHeaderSeparator: UIKit.UIColor
  public static var loadingViewBackground: UIKit.UIColor
  public static var messageUrlLinkOnAgentBubble: UIKit.UIColor
  public static var messageUrlLinkOnCustomerBubble: UIKit.UIColor
  public static var messageLinkInHistoryList: UIKit.UIColor
  public static var messagesBackground: UIKit.UIColor
  public static var navigationBarButton: UIKit.UIColor
  public static var outgoingMessageBubble: UIKit.UIColor
  public static var outgoingMessageText: UIKit.UIColor
  public static var tabBarBackground: UIKit.UIColor
  public static var tabBarItemColor: UIKit.UIColor
  public static var tabBarUnselectedItemColor: UIKit.UIColor
  public static var kbBrowseBackground: UIKit.UIColor
  public static var kbBrowseSeparator: UIKit.UIColor?
  public static var kbLoadingProgressTintColor: UIKit.UIColor?
  public static var kbLoadingTintColor: UIKit.UIColor?
  public static var kobjectButton: UIKit.UIColor?
  public static var kobjectButtonText: UIKit.UIColor?
  public static var kbBrowseRowTitle: UIKit.UIColor?
  public static var kbBrowseRowSubtitle: UIKit.UIColor?
  public static var kbBrowseCategoryDescriptionText: UIKit.UIColor?
  public static var kbBrowseIconTint: UIKit.UIColor?
  public static var kbHeader: UIKit.UIColor
  public static var kbHeaderText: UIKit.UIColor
  public static var kbHeaderTint: UIKit.UIColor
  @available(*, deprecated, message: "Knowledge Base Articles will soon load as embedded web views - please use the Kustomer Web Portal for all Knowledge Base article formatting")
  public static var kbArticleBackgroundLight: UIKit.UIColor
  @available(*, deprecated, message: "Knowledge Base Articles will soon load as embedded web views - please use the Kustomer Web Portal for all Knowledge Base article formatting")
  public static var kbArticleBackgroundDark: UIKit.UIColor
  @available(*, deprecated, message: "Knowledge Base Articles will soon load as embedded web views - please use the Kustomer Web Portal for all Knowledge Base article formatting")
  public static var kbSurveySubmitButton: UIKit.UIColor
  @available(*, deprecated, message: "Knowledge Base Articles will soon load as embedded web views - please use the Kustomer Web Portal for all Knowledge Base article formatting")
  public static var kbSurveySubmitButtonText: UIKit.UIColor
  public static var chatMllMenuOpenBackdrop: UIKit.UIColor
  public static var mllOptionText: UIKit.UIColor
  public static var mllMenuTitleText: UIKit.UIColor
  public static var mllMenuBackTint: UIKit.UIColor
  public static var quickActionButton: UIKit.UIColor
  public static var quickActionButtonText: UIKit.UIColor
  public static var sendChatMessageButton: UIKit.UIColor
  public static var noInternetBannerBackground: UIKit.UIColor
  public static var noInternetBannerText: UIKit.UIColor
}
public protocol Coordinator : AnyObject {
  var delegate: KustomerChat.CoordinatorDelegate? { get set }
  var view: UIKit.UIViewController { get }
  var navigationController: UIKit.UINavigationController? { get set }
  func show(in navigationController: UIKit.UINavigationController?)
  func present(in controller: UIKit.UIViewController)
}
extension KustomerChat.Coordinator {
  public func show(in navigationController: UIKit.UINavigationController?)
  public func present(in controller: UIKit.UIViewController)
}
public enum KustomerConfigurationError : Swift.Error {
  case notEnoughDiskSpace
  public static func == (a: KustomerChat.KustomerConfigurationError, b: KustomerChat.KustomerConfigurationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension KustomerChat.KustomerConfigurationError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum KUSConversationLockReason : Swift.String {
  case customer_ended
  case user_ended
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KnowledgeBaseDocumentType : Swift.String, Swift.Decodable {
  case article, category
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KBDocument : Swift.Decodable {
  case article(KustomerChat.KnowledgeBaseArticle)
  case category(KustomerChat.KnowledgeBaseCategory)
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseResponse : Swift.Decodable {
  public let data: KustomerChat.KnowledgeBaseCategory
  public var subCategories: [KustomerChat.KnowledgeBaseCategory]? {
    get
  }
  public var articles: [KustomerChat.KnowledgeBaseArticle]? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseCategory : Swift.Decodable {
  public let id: Swift.String
  public let type: KustomerChat.KnowledgeBaseDocumentType
  public let attributes: KustomerChat.KnowledgeBaseCategoryAttributes
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseCategoryAttributes : Swift.Decodable {
  public let title: Swift.String?
  public let description: Swift.String?
  public var disabled: Swift.Bool?
  public let positions: [Swift.String]
  public let categoryPositions: [Swift.String]
  public let parent: Swift.String?
  public let createdAt: Foundation.Date
  public let updatedAt: Foundation.Date
  public let published: Swift.Bool
  public var deleted: Swift.Bool?
  public let slug: Swift.String?
  public let hash: Swift.String?
  public var root: Swift.Bool?
  public init(from decoder: Swift.Decoder) throws
}
public class KUSChatSettings {
  public init(userDefaults: Foundation.UserDefaults)
  public var dictionaryRepresentation: [Swift.String : Any] {
    get
  }
  @objc deinit
}
public enum KustomerOffhoursDisplay : Swift.String {
  case none
  case offline
  case online
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KnowledgeBaseCategoryViewMode : Swift.CaseIterable {
  case rootCategory
  case subCategory
  public static func == (a: KustomerChat.KnowledgeBaseCategoryViewMode, b: KustomerChat.KnowledgeBaseCategoryViewMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [KustomerChat.KnowledgeBaseCategoryViewMode]
  public static var allCases: [KustomerChat.KnowledgeBaseCategoryViewMode] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public enum KUSChatMessageStatus {
  case success
  case error
  case sending
  case cancelled
  public static func fromString(_ s: Swift.String?) -> KustomerChat.KUSChatMessageStatus
  public static func == (a: KustomerChat.KUSChatMessageStatus, b: KustomerChat.KUSChatMessageStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum KUSMessageTemplateType : Swift.String, Swift.Decodable {
  case quickReplies
  case mll
  case deflection
  case text
  case list
  case none
  public static func fromString(_ s: Swift.String?) -> KustomerChat.KUSMessageTemplateType
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum PresenceType {
  case online
  case offline
  public static func == (a: KustomerChat.PresenceType, b: KustomerChat.PresenceType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol LineStyling {
  var shouldTokeniseLine: Swift.Bool { get }
  func styleIfFoundStyleAffectsPreviousLine() -> KustomerChat.LineStyling?
}
public struct SwiftyLine : Swift.CustomStringConvertible {
  public let line: Swift.String
  public let lineStyle: KustomerChat.LineStyling
  public var description: Swift.String {
    get
  }
}
extension KustomerChat.SwiftyLine : Swift.Equatable {
  public static func == (lhs: KustomerChat.SwiftyLine, rhs: KustomerChat.SwiftyLine) -> Swift.Bool
}
public enum Remove {
  case leading
  case trailing
  case both
  case entireLine
  case none
  public static func == (a: KustomerChat.Remove, b: KustomerChat.Remove) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ChangeApplication {
  case current
  case previous
  case untilClose
  public static func == (a: KustomerChat.ChangeApplication, b: KustomerChat.ChangeApplication) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FrontMatterRule {
}
public struct LineRule {
  public init(token: Swift.String, type: KustomerChat.LineStyling, removeFrom: KustomerChat.Remove = .leading, shouldTrim: Swift.Bool = true, changeAppliesTo: KustomerChat.ChangeApplication = .current)
}
public class SwiftyLineProcessor {
  public var processEmptyStrings: KustomerChat.LineStyling?
  public var frontMatterAttributes: [Swift.String : Swift.String] {
    get
  }
  public init(rules: [KustomerChat.LineRule], defaultRule: KustomerChat.LineStyling, frontMatterRules: [KustomerChat.FrontMatterRule] = [])
  public func process(_ string: Swift.String) -> [KustomerChat.SwiftyLine]
  @objc deinit
}
public enum KError : Swift.Error {
  case named(Swift.String)
  case generic(Swift.Error)
  case alamofire(KustomerChat.KUSAFError)
  case api(details: [Any]?)
  case notEnoughDiskSpace
  case noAPSEnvironmentEntitlement
  case invalidDeviceToken
  case pushRegistrationNotNeededNoCustomerIPC
  case noDeviceToken
  case identificationFailed(Swift.String)
  case loginValidationError(error: Swift.String)
  case channelGroupNameNotFound
  case invalidJwt
  case alreadyIdentifiedWithExternalId(externalId: Swift.String)
  case alreadyIdentifiedWithEmail(email: Swift.String)
  case networkErrorLoadingSettings(KustomerChat.KustomerError)
  case noPubNubClient
  case couldNotDeregisterPush
  case couldNotDeregisterPushBecause(Swift.Error)
  case couldNotDeregisterPushBecauseOf(Swift.String)
  case attachmentTooLarge
  case localFileURLExpired
  case localFileURLHasNoData
  case unknownLanguageCode(Swift.String)
  case describe(details: [Any]?)
  case describeUnknownParameter(parameter: Swift.String, details: [Any]?)
  case describeParameterWrongType(parameter: Swift.String, details: [Any]?)
  case describeNoParamtersSpecified
  case describeCustomerDateParametersNotSupported
  case describeNotAvailableForLocalCustomer
  case describeNotSignedInAsThatCustomerId
  case describeCurrentCustomerIsAnonymous
  case kbNetworkError
  case kbArticleIdNotFound
  case kbCategoryIdNotFound
  case localDataStoreError
  case kbNoParentCategoryIdSpecified
  case invalidConversationId
  case malformedConversationId
  case unauthorizedConversationId
  case genericOpenConversationError(details: Swift.String)
  case couldNotCreateSession
  case cancelledMessageCreateDataRequest
  case chatEnded
  case internetOffline
  case invalidAssistantId
  case noInternetAvailableAndNoCachedChatAssistantFound
  case couldNotReadLocalFile
  case httpAttachmentUploadWasCancelled
  case invalidBusinessScheduleId
  case invalidBrandId
  case chatAvailError(reason: Swift.String)
  case noCustomerMetaChannelName
  case pubsubHistoryLoadError(failed: [Swift.String : KustomerChat.KError])
  case tooManyChannelKeysInHistoricalCustomerEvents
  case couldNotLoadMessageHistory(error: Swift.Error)
}
extension KustomerChat.KError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class KUSSatisfaction : Swift.Codable {
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
public enum KustomerDisplayMode {
  case `default`
  case chatHistory
  case newChat
  case activeChat
  case knowledgeBase
  case knowledgeBaseHome
  case onlyChat
  case onlyKnowledgeBase
  public static func == (a: KustomerChat.KustomerDisplayMode, b: KustomerChat.KustomerDisplayMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum KUSConversationStatus {
  case open
  case ended
  case new
  public static func == (a: KustomerChat.KUSConversationStatus, b: KustomerChat.KUSConversationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum CharacterStyle : KustomerChat.CharacterStyling {
  case none
  case bold
  case italic
  case code
  case link
  case image
  case referencedLink
  case referencedImage
  case strikethrough
  public func isEqualTo(_ other: KustomerChat.CharacterStyling) -> Swift.Bool
  public static func == (a: KustomerChat.CharacterStyle, b: KustomerChat.CharacterStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public enum FontStyle : Swift.Int {
  case normal
  case bold
  case italic
  case boldItalic
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol FontProperties {
  @objc var fontName: Swift.String? { get set }
  @objc var color: UIKit.UIColor { get set }
  @objc var fontSize: CoreGraphics.CGFloat { get set }
  @objc var fontStyle: KustomerChat.FontStyle { get set }
}
@objc public protocol LineProperties {
  @objc var alignment: UIKit.NSTextAlignment { get set }
  @objc var lineSpacing: CoreGraphics.CGFloat { get set }
  @objc var paragraphSpacing: CoreGraphics.CGFloat { get set }
}
@_inheritsConvenienceInitializers @objc open class BasicStyles : ObjectiveC.NSObject, KustomerChat.FontProperties {
  @objc public var fontName: Swift.String?
  @objc public var color: UIKit.UIColor
  @objc public var fontSize: CoreGraphics.CGFloat
  @objc public var fontStyle: KustomerChat.FontStyle
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc open class LineStyles : ObjectiveC.NSObject, KustomerChat.FontProperties, KustomerChat.LineProperties {
  @objc public var fontName: Swift.String?
  @objc public var color: UIKit.UIColor
  @objc public var fontSize: CoreGraphics.CGFloat
  @objc public var fontStyle: KustomerChat.FontStyle
  @objc public var alignment: UIKit.NSTextAlignment
  @objc public var lineSpacing: CoreGraphics.CGFloat
  @objc public var paragraphSpacing: CoreGraphics.CGFloat
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc open class LinkStyles : KustomerChat.BasicStyles {
  public var underlineStyle: UIKit.NSUnderlineStyle
  public var underlineColor: UIKit.UIColor {
    get
    set
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc open class SwiftyMarkdown : ObjectiveC.NSObject {
  public static var frontMatterRules: [KustomerChat.FrontMatterRule]
  public static var lineRules: [KustomerChat.LineRule]
  public static var characterRules: [KustomerChat.CharacterRule]
  open var h1: KustomerChat.LineStyles
  open var h2: KustomerChat.LineStyles
  open var h3: KustomerChat.LineStyles
  open var h4: KustomerChat.LineStyles
  open var h5: KustomerChat.LineStyles
  open var h6: KustomerChat.LineStyles
  open var body: KustomerChat.LineStyles
  open var blockquotes: KustomerChat.LineStyles
  open var link: KustomerChat.LinkStyles
  open var bold: KustomerChat.BasicStyles
  open var italic: KustomerChat.BasicStyles
  open var code: KustomerChat.BasicStyles
  open var strikethrough: KustomerChat.BasicStyles
  public var bullet: Swift.String
  public var underlineLinks: Swift.Bool
  public var frontMatterAttributes: [Swift.String : Swift.String] {
    get
  }
  public init(string: Swift.String)
  public init?(url: Foundation.URL)
  open func setFontSizeForAllStyles(with size: CoreGraphics.CGFloat)
  open func setFontColorForAllStyles(with color: UIKit.UIColor)
  open func setFontNameForAllStyles(with name: Swift.String)
  open func attributedString(from markdownString: Swift.String? = nil) -> Foundation.NSAttributedString
  @objc deinit
}
public enum NetworkError : Swift.Error, Foundation.LocalizedError {
  case failed(Swift.Error?)
  case outdated
  case badRequest(Swift.Int, [Swift.String : Swift.AnyObject]?)
  case serverError(Swift.Int, [Swift.String : Swift.AnyObject]?)
  case authenticationError
  case requestError(KustomerChat.RequestError)
  case responseError(KustomerChat.ResponseError)
  public var errorDescription: Swift.String? {
    get
  }
}
public enum RequestError : Swift.Error, Foundation.LocalizedError {
  case invalidRequest(Swift.String)
  case parametersNil
  case parameterEncodingFailed(KustomerChat.ParameterEncodingFailureReason)
  public var errorDescription: Swift.String? {
    get
  }
}
public enum ParameterEncodingFailureReason {
  case missingUrl
  case jsonEncoding(Swift.Error)
  public var description: Swift.String? {
    get
  }
}
public enum ResponseError : Swift.Error, Foundation.LocalizedError {
  case unableToDecode(Swift.DecodingError)
  case noData(Swift.String)
  case noContent
  public var errorDescription: Swift.String? {
    get
  }
}
public enum KUSAFError : Swift.Error {
  public enum KUSMultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public enum KUSParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case customEncodingFailed(error: Swift.Error)
  }
  public enum KUSParameterEncoderFailureReason {
    public enum KUSRequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(KustomerChat.KUSAFError.KUSParameterEncoderFailureReason.KUSRequiredComponent)
    case encoderFailed(error: Swift.Error)
  }
  public enum KUSResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: Swift.Error)
  }
  public enum KUSResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case decodingFailed(error: Swift.Error)
    case customSerializationFailed(error: Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum KUSServerTrustFailureReason {
    public struct KUSOutput {
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: Swift.Error?)
    case defaultEvaluationFailed(output: KustomerChat.KUSAFError.KUSServerTrustFailureReason.KUSOutput)
    case hostValidationFailed(output: KustomerChat.KUSAFError.KUSServerTrustFailureReason.KUSOutput)
    case revocationCheckFailed
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: Swift.Error)
  }
  public enum KUSURLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: Swift.Error)
  case createURLRequestFailed(error: Swift.Error)
  case downloadedFileMoveFailed(error: Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: KustomerChat.KUSURLConvertible)
  case multipartEncodingFailed(reason: KustomerChat.KUSAFError.KUSMultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: KustomerChat.KUSAFError.KUSParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: KustomerChat.KUSAFError.KUSParameterEncoderFailureReason)
  case requestAdaptationFailed(error: Swift.Error)
  case requestRetryFailed(retryError: Swift.Error, originalError: Swift.Error)
  case responseValidationFailed(reason: KustomerChat.KUSAFError.KUSResponseValidationFailureReason)
  case responseSerializationFailed(reason: KustomerChat.KUSAFError.KUSResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: KustomerChat.KUSAFError.KUSServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: Swift.Error?)
  case sessionTaskFailed(error: Swift.Error)
  case urlRequestValidationFailed(reason: KustomerChat.KUSAFError.KUSURLRequestValidationFailureReason)
  case kustomerAddOnError(error: Foundation.NSError)
}
extension KustomerChat.KUSAFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum KustomerLogType : Swift.String {
  case debug
  case warning
  case error
  case info
  case fatal
  @available(*, deprecated)
  case multithreadingWarning
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public let KustomerLogTypeAll: [KustomerChat.KustomerLogType]
public typealias KUSCustomDescribe = [Swift.String : Swift.String]
@objc @_inheritsConvenienceInitializers final public class KustomerClient : ObjectiveC.NSObject {
  final public var chatProvider: KustomerChat.ChatProvider {
    get
    set
  }
  final public var kbProvider: KustomerChat.KnowledgeBaseProvider {
    get
    set
  }
  final public var pushProvider: KustomerChat.PushProvider
  public static let shared: KustomerChat.KustomerClient
  final public var status: KustomerChat.KustomerClientStatus
  final public var bundle: Foundation.Bundle
  final public let sdkVersion: Swift.String
  final public let sdkVersionBuild: Swift.String
  final public var sdkVersionSemver: Swift.String {
    get
  }
  final public var rootViewController: KustomerChat.SupportTabViewController? {
    get
  }
  final public class var isRunningOnSimulator: Swift.Bool {
    get
  }
  final public func changeActiveAssistant(_ na: KustomerChat.ActiveAssistantOptions)
  @available(*, deprecated, message: "Changing brand ID's on the fly is no longer supported")
  final public func changeBrand(brandId nbid: Swift.String, completion: ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void)? = nil)
  final public func changeBusinessSchedule(scheduleId: Swift.String?, completion: ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void)? = nil)
  final public func getActiveAssistantID() -> Swift.String?
  final public func getActiveAssistantStartDialog() -> Swift.String?
  final public var options: KustomerChat.KustomerOptions {
    get
  }
  final public var orgId: Swift.String
  final public var orgName: Swift.String {
    get
    set
  }
  @available(*, deprecated)
  final public var apiKeyRaw: Swift.String? {
    get
  }
  final public func configure(apiKey: Swift.String, options: KustomerChat.KustomerOptions?, launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]?, completion: ((KustomerChat.KustomerConfigurationError) -> ())? = { _ in }, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line) -> KustomerChat.KustomerClient
  final public func configureUnsafe(apiKey: Swift.String, options: KustomerChat.KustomerOptions?, launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]?, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line) -> KustomerChat.KustomerClient
  final public func isChatAvailable() -> Swift.Bool?
  final public func show(presentingVC: UIKit.UIViewController? = nil)
  final public func show(preferredView: KustomerChat.KustomerDisplayMode, presentingVC: UIKit.UIViewController? = nil)
  final public func openConversation(id: Swift.String, animated: Swift.Bool = true, presentingVC: UIKit.UIViewController? = nil, completion: ((Swift.Result<KustomerChat.KUSConversation, KustomerChat.KError>) -> Swift.Void)? = nil)
  final public func showKbArticle(id: Swift.String, presentingVC: UIKit.UIViewController? = nil)
  final public func showKbCategory(id: Swift.String, presentingVC: UIKit.UIViewController? = nil)
  final public func close(animated: Swift.Bool = true, completion passedCompletion: (() -> Swift.Void)?)
  final public var isVisible: Swift.Bool {
    get
  }
  final public func isLoggedIn(userEmail: Swift.String?, userId: Swift.String?) -> Swift.Bool
  @available(*, deprecated, message: "Use isLoggedIn(userEmail: String?, userId: String?) -> Bool")
  final public func isLoggedIn(userEmail: Swift.String?, userId: Swift.String?, completion: @escaping ((Swift.Result<Swift.Bool, KustomerChat.KError>) -> Swift.Void))
  final public func logOut(_ completion: @escaping ((KustomerChat.KError?) -> Swift.Void))
  final public func logIn(jwt: Swift.String, _ completion: @escaping ((Swift.Result<KustomerChat.KUSTrackingIdentity, KustomerChat.KError>) -> Swift.Void))
  final public func logOutThenLogIn(jwt: Swift.String, _ completion: @escaping ((Swift.Result<KustomerChat.KUSTrackingIdentity, KustomerChat.KError>) -> Swift.Void))
  @available(*, deprecated, message: "Use startNewConversation() instead")
  final public func openNewConversation(initialMessages: [Swift.String]? = nil, presentingVC: UIKit.UIViewController? = nil, afterCreateConversation: ((KustomerChat.KUSConversation) -> Swift.Void)? = nil, animated: Swift.Bool = true)
  final public func startNewConversation(initialMessage: KustomerChat.KUSInitialMessage? = nil, customDescribe: KustomerChat.KUSCustomDescribe? = nil, presentingVC: UIKit.UIViewController? = nil, afterCreateConversation: ((KustomerChat.KUSConversation) -> Swift.Void)? = nil, animated: Swift.Bool = true)
  final public func didFailToRegisterForRemoteNotifications(error: Swift.Error)
  final public func didRegisterForRemoteNotifications(deviceToken: Foundation.Data)
  final public func deregisterCurrentDeviceForPushNotifications(_ completion: @escaping ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void))
  final public func requestAuthorizationForPush()
  final public func stop()
  final public func start(completion: @escaping (() -> Swift.Void), failure: @escaping ((Swift.Error) -> Swift.Void))
  final public func start()
  final public func start(completion: @escaping (() -> Swift.Void))
  final public func start(failure: @escaping ((Swift.Error) -> Swift.Void))
  final public var unUserNotificationCenterDelegate: UserNotifications.UNUserNotificationCenterDelegate? {
    get
    set
  }
  final public func printLocalizationKeys()
  @available(*, deprecated, message: "This functionality is deprecated and will be removed in a future version. Please user KustomerOptions.language to set a language")
  final public func overrideAssetLanguage(languageCode: KustomerChat.KustomerAssetLanguage)
  @objc override dynamic public init()
  final public func openChatAssistant(id: Swift.String, startDialog: Swift.String?, presentingVC: UIKit.UIViewController? = nil, completion: @escaping ((Swift.Result<Swift.Void, KustomerChat.KError>) -> Swift.Void), afterFirstMessage: @escaping ((KustomerChat.KUSConversation) -> Swift.Void) = { c in }, initialMessages: [Swift.String]? = nil, customDescribe: KustomerChat.KUSCustomDescribe? = nil, animated: Swift.Bool = true)
  final public func getUnreadCount(completion: @escaping (Swift.Result<Swift.Int, KustomerChat.KError>) -> Swift.Void)
  final public func getOpenConversationCount(completion: @escaping (Swift.Result<Swift.Int, KustomerChat.KError>) -> Swift.Void)
  @objc deinit
}
extension KustomerChat.KustomerClient : UIKit.UIAdaptivePresentationControllerDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func presentationControllerDidDismiss(_ presentationController: UIKit.UIPresentationController)
}
extension Foundation.Bundle {
  public static func getBundle(bundleName: Swift.String) -> Foundation.Bundle?
  public static let kustomerAssets: Foundation.Bundle?
}
public enum PushEnvironment : Swift.String {
  case development
  case production
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class Schedules {
  public var timeZone: Swift.String {
    get
    set
  }
  public var hours: [KustomerChat.BusinessHours] {
    get
    set
  }
  public var holidays: [KustomerChat.BusinessHoliday] {
    get
    set
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KUSAssistant : Swift.CustomStringConvertible, Swift.Decodable {
  public var dialog: Swift.String
  public var id: Swift.String
  public var node: Swift.String
  public var initialMessagesRawJson: [Any]
  public var publicName: Swift.String?
  public var avatarUrl: Swift.String?
  public var messages: [KustomerChat.KUSChatMessage] {
    get
  }
  required public init(from decoder: Swift.Decoder) throws
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class SupportTabViewController : UIKit.UITabBarController {
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidLayoutSubviews()
  @_Concurrency.MainActor(unsafe) final public var isCurrentlyVisible: Swift.Bool {
    get
  }
}
extension KustomerChat.SupportTabViewController : KustomerChat.KUSChatListener {
  @_Concurrency.MainActor(unsafe) final public func onUnreadCountChange(count: Swift.Int)
}
extension KustomerChat.SupportTabViewController : KustomerChat.CoordinatorDelegate {
  @_Concurrency.MainActor(unsafe) final public func coordinatorDidHide(_ coordinator: KustomerChat.Coordinator)
}
public struct BusinessHoliday : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum KustomerError : Swift.Error {
  case networkError(KustomerChat.NetworkError)
  case someError(Swift.String)
}
extension KustomerChat.KustomerError : Foundation.LocalizedError {
  public var failureReason: Swift.String? {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
}
public struct KSet : Swift.Decodable {
  public var publishKey: Swift.String?
  public var subscribeKey: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseSurveyResponse : Swift.Decodable {
  public let id: Swift.String
  public let attributes: KustomerChat.KnowledgeBaseSurveyResponseAttributes
  public init(from decoder: Swift.Decoder) throws
}
public struct KnowledgeBaseSurveyResponseAttributes : Swift.Codable {
  public let rating: KustomerChat.KBSurveyRating?
  public let writtenFeedback: Swift.String?
  public let suggestedReasons: [Swift.String]?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum KBSurveyRating : Swift.String, Swift.Codable {
  case positive
  case negative
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol KBCategoryCollectionManager : AnyObject {
  var dataSource: KustomerChat.KBCategoryCollectionDataSource? { get set }
  func reload()
}
public class KUSKBCategory : KustomerChat.KUSKBItemBase, Swift.CustomStringConvertible {
  public var id: Swift.String?
  public var htmlBody: Swift.String?
  public var title: Swift.String?
  public var metaDescription: Swift.String?
  public var rawJson: Swift.String?
  public var isRoot: Swift.Bool
  public var categoryDescription: Swift.String?
  public var lang: Swift.String?
  public var slug: Swift.String?
  public init()
  public var description: Swift.String {
    get
  }
  @objc deinit
}
public struct KUSChatMessage : Swift.CustomStringConvertible, Swift.Decodable {
  public var id: Swift.String
  public var conversationId: Swift.String?
  public var createdAt: Foundation.Date?
  public var status: KustomerChat.KUSChatMessageStatus?
  public var messageType: KustomerChat.KUSMessageType?
  public var direction: KustomerChat.KUSChatMessageDirection?
  public var directionType: KustomerChat.KUSChatMessageDirectionType?
  public var body: Swift.String?
  public var attachments: [KustomerChat.KUSChatAttachment]
  public var templateType: KustomerChat.KUSMessageTemplateType?
  public var sentByUser: KustomerChat.KUSUser?
  public var sentById: Swift.String?
  public var sentByType: KustomerChat.KUSSentByType?
  public var actions: [KustomerChat.KUSMessageAction]?
  public var mllNode: KustomerChat.KUSMLLNode? {
    get
    set
  }
  public var deflectResults: [KustomerChat.KUSKBDeflectResult]?
  public var followupText: Swift.String?
  public var satisfaction: KustomerChat.KUSSatisfaction?
  public var pubNubTimetoken: Swift.UInt64?
  public var templateRawJson: Swift.String?
  public var previewSummary: Swift.String {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ChatHistoryCoordinator : KustomerChat.CoordinatorCreator, KustomerChat.Coordinator {
  weak final public var delegate: KustomerChat.CoordinatorDelegate?
  final public var view: UIKit.UIViewController
  weak final public var navigationController: UIKit.UINavigationController?
  final public var currentCoordinator: KustomerChat.Coordinator?
  public static func make() -> KustomerChat.Coordinator
  final public func show(in navigationController: UIKit.UINavigationController?)
  @objc deinit
}
public enum KustomerUI {
}
extension KustomerChat.KustomerUI {
  @_hasMissingDesignatedInitializers public class Color {
    @objc deinit
  }
}
extension KustomerChat.KustomerUI.Color {
  public static var systemBackground: UIKit.UIColor {
    get
  }
  public static var secondarySystemGroupedBackground: UIKit.UIColor {
    get
  }
  public static var systemGray5: UIKit.UIColor {
    get
  }
  public static var tertiarySystemGroupedBackground: UIKit.UIColor {
    get
  }
  public static var label: UIKit.UIColor {
    get
  }
  public static var secondaryLabel: UIKit.UIColor {
    get
  }
  public static var tertiaryLabel: UIKit.UIColor {
    get
  }
  public static var systemGray3: UIKit.UIColor {
    get
  }
  public static var systemFill: UIKit.UIColor {
    get
  }
  public static func color(_ named: Swift.String) -> UIKit.UIColor?
}
public struct KnowledgeBaseDomain : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension KustomerChat.KnowledgeBaseDomain {
  public struct Attributes : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
}
extension KustomerChat.KnowledgeBaseDomain {
  public enum Status : Swift.Codable, Swift.RawRepresentable {
    public typealias RawValue = Swift.String
    case ready
    case some(value: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public init(rawValue: Swift.String)
  }
}
public class SwiftyTokeniser {
  public var metadataLookup: [Swift.String : Swift.String]
  public init(with rules: [KustomerChat.CharacterRule])
  @objc deinit
  public func process(_ inputString: Swift.String) -> [KustomerChat.Token]
}
public struct KUSInitialMessage {
  public init(body: Swift.String, direction: KustomerChat.KUSInitialMessageDirection)
}
public enum KUSInitialMessageDirection {
  case agent
  case user
  public static func == (a: KustomerChat.KUSInitialMessageDirection, b: KustomerChat.KUSInitialMessageDirection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension KustomerChat.KustomerLanguage : Swift.Equatable {}
extension KustomerChat.KustomerLanguage : Swift.Hashable {}
extension KustomerChat.KustomerLanguage : Swift.RawRepresentable {}
extension KustomerChat.KustomerAssetLanguage : Swift.Equatable {}
extension KustomerChat.KustomerAssetLanguage : Swift.Hashable {}
extension KustomerChat.KustomerAssetLanguage : Swift.RawRepresentable {}
extension KustomerChat.Weekday : Swift.Equatable {}
extension KustomerChat.Weekday : Swift.Hashable {}
extension KustomerChat.Weekday : Swift.RawRepresentable {}
extension KustomerChat.KUSCSATScaleType : Swift.Equatable {}
extension KustomerChat.KUSCSATScaleType : Swift.Hashable {}
extension KustomerChat.KUSCSATQuestionType : Swift.Equatable {}
extension KustomerChat.KUSCSATQuestionType : Swift.Hashable {}
extension KustomerChat.KUSCSATQuestionType : Swift.RawRepresentable {}
extension KustomerChat.KUSKBDeflectResultType : Swift.Equatable {}
extension KustomerChat.KUSKBDeflectResultType : Swift.Hashable {}
extension KustomerChat.KUSKBDeflectResultType : Swift.RawRepresentable {}
extension KustomerChat.KUSSentByType : Swift.Equatable {}
extension KustomerChat.KUSSentByType : Swift.Hashable {}
extension KustomerChat.KUSSentByType : Swift.RawRepresentable {}
extension KustomerChat.TokenType : Swift.Equatable {}
extension KustomerChat.TokenType : Swift.Hashable {}
extension KustomerChat.SpaceAllowed : Swift.Equatable {}
extension KustomerChat.SpaceAllowed : Swift.Hashable {}
extension KustomerChat.Cancel : Swift.Equatable {}
extension KustomerChat.Cancel : Swift.Hashable {}
extension KustomerChat.CharacterRuleTagType : Swift.Equatable {}
extension KustomerChat.CharacterRuleTagType : Swift.Hashable {}
extension KustomerChat.KustomerConnectionStatus : Swift.Equatable {}
extension KustomerChat.KustomerConnectionStatus : Swift.Hashable {}
extension KustomerChat.KustomerConnectionStatus : Swift.RawRepresentable {}
extension KustomerChat.KUSCSATStatus : Swift.Equatable {}
extension KustomerChat.KUSCSATStatus : Swift.Hashable {}
extension KustomerChat.KUSCSATStatus : Swift.RawRepresentable {}
extension KustomerChat.KUSChatMessageDirection : Swift.Equatable {}
extension KustomerChat.KUSChatMessageDirection : Swift.Hashable {}
extension KustomerChat.KUSChatMessageDirection : Swift.RawRepresentable {}
extension KustomerChat.KUSChatMessageDirectionType : Swift.Equatable {}
extension KustomerChat.KUSChatMessageDirectionType : Swift.Hashable {}
extension KustomerChat.KUSChatMessageDirectionType : Swift.RawRepresentable {}
extension KustomerChat.KustomerConfigurationError : Swift.Equatable {}
extension KustomerChat.KustomerConfigurationError : Swift.Hashable {}
extension KustomerChat.KUSConversationLockReason : Swift.Equatable {}
extension KustomerChat.KUSConversationLockReason : Swift.Hashable {}
extension KustomerChat.KUSConversationLockReason : Swift.RawRepresentable {}
extension KustomerChat.KnowledgeBaseDocumentType : Swift.Equatable {}
extension KustomerChat.KnowledgeBaseDocumentType : Swift.Hashable {}
extension KustomerChat.KnowledgeBaseDocumentType : Swift.RawRepresentable {}
extension KustomerChat.KustomerOffhoursDisplay : Swift.Equatable {}
extension KustomerChat.KustomerOffhoursDisplay : Swift.Hashable {}
extension KustomerChat.KustomerOffhoursDisplay : Swift.RawRepresentable {}
extension KustomerChat.KnowledgeBaseCategoryViewMode : Swift.Equatable {}
extension KustomerChat.KnowledgeBaseCategoryViewMode : Swift.Hashable {}
extension KustomerChat.KUSChatMessageStatus : Swift.Equatable {}
extension KustomerChat.KUSChatMessageStatus : Swift.Hashable {}
extension KustomerChat.KUSMessageTemplateType : Swift.Equatable {}
extension KustomerChat.KUSMessageTemplateType : Swift.Hashable {}
extension KustomerChat.KUSMessageTemplateType : Swift.RawRepresentable {}
extension KustomerChat.PresenceType : Swift.Equatable {}
extension KustomerChat.PresenceType : Swift.Hashable {}
extension KustomerChat.Remove : Swift.Equatable {}
extension KustomerChat.Remove : Swift.Hashable {}
extension KustomerChat.ChangeApplication : Swift.Equatable {}
extension KustomerChat.ChangeApplication : Swift.Hashable {}
extension KustomerChat.KustomerDisplayMode : Swift.Equatable {}
extension KustomerChat.KustomerDisplayMode : Swift.Hashable {}
extension KustomerChat.KUSConversationStatus : Swift.Equatable {}
extension KustomerChat.KUSConversationStatus : Swift.Hashable {}
extension KustomerChat.CharacterStyle : Swift.Equatable {}
extension KustomerChat.CharacterStyle : Swift.Hashable {}
extension KustomerChat.FontStyle : Swift.Equatable {}
extension KustomerChat.FontStyle : Swift.Hashable {}
extension KustomerChat.FontStyle : Swift.RawRepresentable {}
extension KustomerChat.KustomerLogType : Swift.Equatable {}
extension KustomerChat.KustomerLogType : Swift.Hashable {}
extension KustomerChat.KustomerLogType : Swift.RawRepresentable {}
extension KustomerChat.PushEnvironment : Swift.Equatable {}
extension KustomerChat.PushEnvironment : Swift.Hashable {}
extension KustomerChat.PushEnvironment : Swift.RawRepresentable {}
extension KustomerChat.KBSurveyRating : Swift.Equatable {}
extension KustomerChat.KBSurveyRating : Swift.Hashable {}
extension KustomerChat.KBSurveyRating : Swift.RawRepresentable {}
extension KustomerChat.KUSInitialMessageDirection : Swift.Equatable {}
extension KustomerChat.KUSInitialMessageDirection : Swift.Hashable {}
